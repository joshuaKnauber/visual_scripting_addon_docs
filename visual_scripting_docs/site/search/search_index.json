{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction THIS PAGE IS ONLY FOR PYTHON DEVELOPERS! This is the documentation for developing packages for the Serpens - Visual Scripting Addon. It is not a documentation on how to use the addon. Content This documentation goes over creating your own nodes with python. It will give you an overview of the different functions you need to work with and how to set up your packages. It also explains how to distribute your packages to others. Philosophy The aim of Serpens is to make addon development accessible to more people, not to replace python. If people can learn enough from Serpens to at some point not use it anymore and switch to python then that's a success. For packages that means that the goal is not to generate the most efficient python code possible, but to provide the best user experience while doing so. Users should have to be confronted with as little errors as possible and if you need to give errors they should be easily understandable. The best possible outcome is that everything is easy to use but has a lot of possibilities if you combine it with more complex systems or even custom python scripts.","title":"Introduction"},{"location":"#introduction","text":"THIS PAGE IS ONLY FOR PYTHON DEVELOPERS! This is the documentation for developing packages for the Serpens - Visual Scripting Addon. It is not a documentation on how to use the addon.","title":"Introduction"},{"location":"#content","text":"This documentation goes over creating your own nodes with python. It will give you an overview of the different functions you need to work with and how to set up your packages. It also explains how to distribute your packages to others.","title":"Content"},{"location":"#philosophy","text":"The aim of Serpens is to make addon development accessible to more people, not to replace python. If people can learn enough from Serpens to at some point not use it anymore and switch to python then that's a success. For packages that means that the goal is not to generate the most efficient python code possible, but to provide the best user experience while doing so. Users should have to be confronted with as little errors as possible and if you need to give errors they should be easily understandable. The best possible outcome is that everything is easy to use but has a lot of possibilities if you combine it with more complex systems or even custom python scripts.","title":"Philosophy"},{"location":"bugs/","text":"Important! Whatever you do, please don't report your issue in the ratings of the addon . That doesn't help anyone and is just annoying for us as we really depend on those. It also doesn't help you because we can't really respond and help you there . (I wish I didn't have to put this here, but it happens unfortunately) Report a bug Please provide the following information when reporting a bug: A short description of the issue Node causing the issue A screenshot of the error message if existing Addon version Blender version Your operating system List of installed packages (screenshot is fine) You can copy the following template and replace the information relevant to your issue. If you think something is absolutely not related to your problem then just don't add it, we will ask you if we think it is. Try to add as much information as you can, that way we can help you the fastest: Info: # operating system here # blender version here # addon version here Description: # node causing the issue here # short description here Assets: # list of installed packages here # error message screenshot here Contact You can report your issue on any of the following platforms. They are ordered in how fast we can respond (at least most of the time): - Discord - Twitter - Blenderartists - Blendermarket","title":"Bugs"},{"location":"bugs/#report-a-bug","text":"Please provide the following information when reporting a bug: A short description of the issue Node causing the issue A screenshot of the error message if existing Addon version Blender version Your operating system List of installed packages (screenshot is fine) You can copy the following template and replace the information relevant to your issue. If you think something is absolutely not related to your problem then just don't add it, we will ask you if we think it is. Try to add as much information as you can, that way we can help you the fastest: Info: # operating system here # blender version here # addon version here Description: # node causing the issue here # short description here Assets: # list of installed packages here # error message screenshot here","title":"Report a bug"},{"location":"bugs/#contact","text":"You can report your issue on any of the following platforms. They are ordered in how fast we can respond (at least most of the time):","title":"Contact"},{"location":"bugs/#-discord","text":"","title":"- Discord"},{"location":"bugs/#-twitter","text":"","title":"- Twitter"},{"location":"bugs/#-blenderartists","text":"","title":"- Blenderartists"},{"location":"bugs/#-blendermarket","text":"","title":"- Blendermarket"},{"location":"developers/distribution/","text":"Distribution To distribute your packages you need to pack your nodes into a zip file. This zip file should include all your python files in the correct node category folders as well as a package_info.json file. Make sure to include empty __init__.py files for any new categories. my_package.zip | \u251c\u2500\u2500 package_info.json | \u251c\u2500\u2500 Interface \u2502 \u2514\u2500\u2500 new_node.py | \u251c\u2500\u2500 New Category | \u251c\u2500\u2500__init__.py \u2502 \u251c\u2500\u2500 my_node.py \u2502 \u2514\u2500\u2500 my_other_node.py Package Info The package_info.json should look as follows. You can copy this as a base: { \"name\": \"The Name Of Your Package\", \"description\": \"A description of your package that shouldn't be longer than this\", \"author\": \"Your Name\", \"wiki_url\": \"https://www.yourpackagewiki.com\", \"package_version\": [1,0,0], \"serpens_versions\": [[2,0,0]] } Checklist Have you called auto_compile everywhere to make sure the compiler registers changes? Have you caught any possible errors that the user could encounter? Have you set proper and consistent names? Ways of distributing When you are done with creating your package you are ready to distribute it. Here's what you need to know: You can sell your package if you want You do not need to pay us anything for your sales Inform your customers that they need Serpens to use your product We are always happy to promote your package Please message us on discord if you have a package that you want to share so we can add it to the package marketplace as well as let people know about it. This will help both of us to get more interest in Serpens and your packages.","title":"Distribution"},{"location":"developers/distribution/#distribution","text":"To distribute your packages you need to pack your nodes into a zip file. This zip file should include all your python files in the correct node category folders as well as a package_info.json file. Make sure to include empty __init__.py files for any new categories. my_package.zip | \u251c\u2500\u2500 package_info.json | \u251c\u2500\u2500 Interface \u2502 \u2514\u2500\u2500 new_node.py | \u251c\u2500\u2500 New Category | \u251c\u2500\u2500__init__.py \u2502 \u251c\u2500\u2500 my_node.py \u2502 \u2514\u2500\u2500 my_other_node.py","title":"Distribution"},{"location":"developers/distribution/#package-info","text":"The package_info.json should look as follows. You can copy this as a base: { \"name\": \"The Name Of Your Package\", \"description\": \"A description of your package that shouldn't be longer than this\", \"author\": \"Your Name\", \"wiki_url\": \"https://www.yourpackagewiki.com\", \"package_version\": [1,0,0], \"serpens_versions\": [[2,0,0]] }","title":"Package Info"},{"location":"developers/distribution/#checklist","text":"Have you called auto_compile everywhere to make sure the compiler registers changes? Have you caught any possible errors that the user could encounter? Have you set proper and consistent names?","title":"Checklist"},{"location":"developers/distribution/#ways-of-distributing","text":"When you are done with creating your package you are ready to distribute it. Here's what you need to know: You can sell your package if you want You do not need to pay us anything for your sales Inform your customers that they need Serpens to use your product We are always happy to promote your package Please message us on discord if you have a package that you want to share so we can add it to the package marketplace as well as let people know about it. This will help both of us to get more interest in Serpens and your packages.","title":"Ways of distributing"},{"location":"developers/getting_started/","text":"Introduction Serpens allows you to create packages of nodes that can be installed by the user. You are free to develop these packages and share or sell them. A package is a collection of custom python nodes which work with the rest of Serpens nodes. To make that work you'll have to follow a couple of steps which are explained in this documentation. If you develop a package, please let us know so we can promote it. There is also a built in marketplace which we can update over the air. This allows users to look for packages directly in the addon and not have to scout the internet to find them. Please reach out to us via discord when you have a package for us to share. What you will do Your package contains custom nodes which can then be used to generate addons. An addon consists of multiple node trees. When the addon is compiled, all node trees with changes will be compiled. Serpens finds the nodes that are marked as starting points (Panel, Operator, Function, etc.) and calls different functions which evaluate to a string of python code. In this string can be placeholders which call functions on the nodes sockets. These will then automatically deal with the connected nodes to give you the code of the connected node. This way the final code is built. When that process is done, Serpens puts all the code together and installs the module in blender. There are lots of utility functions which help you with the process explained above. Our goal when designing them was to make development of nodes as quick and easy as possible. More info A node can look however you want. You can write custom operators that allow you to select UI elements or have lists, enums, checkboxes, ... You should not add custom socket types. Serpens is technically capable of dealing with them, but things like checking for errors could become more difficult and not work in some cases. If you feel like a socket type is missing, please let us know, the documentation will not go in detail when it comes to developing custom socket types. You should make sure that your nodes have easy to understand names and are in categories that are fitting. Don't choose extreme colors for your nodes. You might want to consider to add a prefix in front of your nodes names to show that they belong together in one package. Development The basic structure in which you will develop is the following: You will distribute a .zip file to others which can then be installed in the Serpens user preferences. Your zip file can hold multiple folders. These folders represent the categories and are where the .py files for the nodes go. You can have python files that don't hold any nodes and just contain utility functions for example. Example: If you want to create a node in the Interface category, you would add a folder called Interface and a python file inside that folder. This is where the code for your node goes. If you create a folder with a name that doesn't exist yet, that category will be created. You can not nest folders to create subcategories! Finally you will need a package_info.json file which also goes in the .zip file. This file holds information on your package. This will be explained in more detail later. An example for the structure of your package .zip file could look as follows: my_package.zip | \u251c\u2500\u2500 package_info.json | \u251c\u2500\u2500 Interface \u2502 \u2514\u2500\u2500 new_node.py | \u251c\u2500\u2500 New Category | \u251c\u2500\u2500__init__.py \u2502 \u251c\u2500\u2500 my_node.py \u2502 \u2514\u2500\u2500 my_other_node.py","title":"Basics"},{"location":"developers/getting_started/#introduction","text":"Serpens allows you to create packages of nodes that can be installed by the user. You are free to develop these packages and share or sell them. A package is a collection of custom python nodes which work with the rest of Serpens nodes. To make that work you'll have to follow a couple of steps which are explained in this documentation. If you develop a package, please let us know so we can promote it. There is also a built in marketplace which we can update over the air. This allows users to look for packages directly in the addon and not have to scout the internet to find them. Please reach out to us via discord when you have a package for us to share.","title":"Introduction"},{"location":"developers/getting_started/#what-you-will-do","text":"Your package contains custom nodes which can then be used to generate addons. An addon consists of multiple node trees. When the addon is compiled, all node trees with changes will be compiled. Serpens finds the nodes that are marked as starting points (Panel, Operator, Function, etc.) and calls different functions which evaluate to a string of python code. In this string can be placeholders which call functions on the nodes sockets. These will then automatically deal with the connected nodes to give you the code of the connected node. This way the final code is built. When that process is done, Serpens puts all the code together and installs the module in blender. There are lots of utility functions which help you with the process explained above. Our goal when designing them was to make development of nodes as quick and easy as possible.","title":"What you will do"},{"location":"developers/getting_started/#more-info","text":"A node can look however you want. You can write custom operators that allow you to select UI elements or have lists, enums, checkboxes, ... You should not add custom socket types. Serpens is technically capable of dealing with them, but things like checking for errors could become more difficult and not work in some cases. If you feel like a socket type is missing, please let us know, the documentation will not go in detail when it comes to developing custom socket types. You should make sure that your nodes have easy to understand names and are in categories that are fitting. Don't choose extreme colors for your nodes. You might want to consider to add a prefix in front of your nodes names to show that they belong together in one package.","title":"More info"},{"location":"developers/getting_started/#development","text":"The basic structure in which you will develop is the following: You will distribute a .zip file to others which can then be installed in the Serpens user preferences. Your zip file can hold multiple folders. These folders represent the categories and are where the .py files for the nodes go. You can have python files that don't hold any nodes and just contain utility functions for example. Example: If you want to create a node in the Interface category, you would add a folder called Interface and a python file inside that folder. This is where the code for your node goes. If you create a folder with a name that doesn't exist yet, that category will be created. You can not nest folders to create subcategories! Finally you will need a package_info.json file which also goes in the .zip file. This file holds information on your package. This will be explained in more detail later. An example for the structure of your package .zip file could look as follows: my_package.zip | \u251c\u2500\u2500 package_info.json | \u251c\u2500\u2500 Interface \u2502 \u2514\u2500\u2500 new_node.py | \u251c\u2500\u2500 New Category | \u251c\u2500\u2500__init__.py \u2502 \u251c\u2500\u2500 my_node.py \u2502 \u2514\u2500\u2500 my_other_node.py","title":"Development"},{"location":"developers/node_code/","text":"Generating code These are the most important functions in your node. They are being used by the compiler to get the actual code that makes up the final addon. They all need to return a dictionary with the code key in it. This contains a string which makes up the code. def code_evaluate(self,context,touched_socket): variable = \"variables\" return { \"code\": f\"\"\" # this is multiline code # we use formatted strings to add {variable} # the leftmost character is used as the base level for indentation # so to indent code you - well... - you indent it... \"\"\" } def code_evaluate(self,context,touched_socket): variable = \"string\" return { \"code\": f\"# this is an inline {variable}. It won't cause a linebreak in the final code\" } Formatted strings are used to put in properties from your node or the values of sockets. These are the functions that you can overwrite: code_evaluate(self, context, touched_socket) This function is used to return the main code for the node. It is called for the start of the node tree and when requesting code from connected nodes. The touched socket is the socket which code was requested from. For data sockets this is always an output where as for execute and interface sockets this is always an input code_imperative(self, context) This function is used to return imperative code. This will be added at the top of the addon file unrelated to anything else and won't be indented by other code code_imports(self, context) This function is used to return the code needed for importing. Serpens addons import bpy, os, math by default so you don't need to import that again code_register(self, context) This returns the code that is used to register this node in code. This code will be added to the addons register() function code_unregister(self, context) This returns the code that is used to unregister this node in code. This code will be added to the addons unregister() function Socket Code With the functions above you should be able to return code from a single node. But if you have inputs or outputs that need to interact with other nodes to get you code, you can use the following functions: socket. code(indents=0) This is certainly the most used function in this category. You call it on the socket of your node that you want to get the code from. An example would be if you have an integer input. You can use formatted code to put the value you get from the socket into your code. You will then call self.inputs[\"My Integer Socket\"].code() on your socket and will get the correct code. This takes into account the value set on the socket itself as well as any connected nodes. If you have a math node connected to your input it will automatically handle calling code_evaluate on that node and give you the code for the math operation. It will also take care of possible errors with different connected data types. If a boolean socket was connected to your integer input it will try to cast it into an integer. While you would always call this function on inputs for data, you always have to call it on your nodes outputs for interface and execute. If you have an execute output leading to the next node you will call self.outputs[0].code(5) to get the code. As you can see in the example node at the top of this page, you'll have to provide indents for this. These indents are the number of indents you can see in your node python file. This is used if the function returns multiple lines of code which is almost always the case for Program sockets. If you are having trouble understanding this function have a look at some of the simpler nodes Serpens has, they all use this a lot socket. by_name(indents=0, separator=\"\") This function acts like the code function but can be used for dynamic sockets. Dynamic sockets will give you a arbitrary amount of sockets with the same name which you would have to account for. This function lets you get all of that code from one socket. Call it on a socket with the name you want and it will return all the code you need. Apart from indents you can also give it a separator which you can for example use to separate all the given values by comma socket. by_type(indents=0, separator=\"\") This function does the same as the by_name function but for the socket type. It will give you the code for all sockets with the type of the socket you call it on node. list_code(value_list, indents=0) If the two functions above don't work for you for some reason, you can use this function to achieve the same with any given code. You pass it a list of strings which represent your code and give it the indents that your code should have","title":"Generating Code"},{"location":"developers/node_code/#generating-code","text":"These are the most important functions in your node. They are being used by the compiler to get the actual code that makes up the final addon. They all need to return a dictionary with the code key in it. This contains a string which makes up the code. def code_evaluate(self,context,touched_socket): variable = \"variables\" return { \"code\": f\"\"\" # this is multiline code # we use formatted strings to add {variable} # the leftmost character is used as the base level for indentation # so to indent code you - well... - you indent it... \"\"\" } def code_evaluate(self,context,touched_socket): variable = \"string\" return { \"code\": f\"# this is an inline {variable}. It won't cause a linebreak in the final code\" } Formatted strings are used to put in properties from your node or the values of sockets. These are the functions that you can overwrite: code_evaluate(self, context, touched_socket) This function is used to return the main code for the node. It is called for the start of the node tree and when requesting code from connected nodes. The touched socket is the socket which code was requested from. For data sockets this is always an output where as for execute and interface sockets this is always an input code_imperative(self, context) This function is used to return imperative code. This will be added at the top of the addon file unrelated to anything else and won't be indented by other code code_imports(self, context) This function is used to return the code needed for importing. Serpens addons import bpy, os, math by default so you don't need to import that again code_register(self, context) This returns the code that is used to register this node in code. This code will be added to the addons register() function code_unregister(self, context) This returns the code that is used to unregister this node in code. This code will be added to the addons unregister() function","title":"Generating code"},{"location":"developers/node_code/#socket-code","text":"With the functions above you should be able to return code from a single node. But if you have inputs or outputs that need to interact with other nodes to get you code, you can use the following functions: socket. code(indents=0) This is certainly the most used function in this category. You call it on the socket of your node that you want to get the code from. An example would be if you have an integer input. You can use formatted code to put the value you get from the socket into your code. You will then call self.inputs[\"My Integer Socket\"].code() on your socket and will get the correct code. This takes into account the value set on the socket itself as well as any connected nodes. If you have a math node connected to your input it will automatically handle calling code_evaluate on that node and give you the code for the math operation. It will also take care of possible errors with different connected data types. If a boolean socket was connected to your integer input it will try to cast it into an integer. While you would always call this function on inputs for data, you always have to call it on your nodes outputs for interface and execute. If you have an execute output leading to the next node you will call self.outputs[0].code(5) to get the code. As you can see in the example node at the top of this page, you'll have to provide indents for this. These indents are the number of indents you can see in your node python file. This is used if the function returns multiple lines of code which is almost always the case for Program sockets. If you are having trouble understanding this function have a look at some of the simpler nodes Serpens has, they all use this a lot socket. by_name(indents=0, separator=\"\") This function acts like the code function but can be used for dynamic sockets. Dynamic sockets will give you a arbitrary amount of sockets with the same name which you would have to account for. This function lets you get all of that code from one socket. Call it on a socket with the name you want and it will return all the code you need. Apart from indents you can also give it a separator which you can for example use to separate all the given values by comma socket. by_type(indents=0, separator=\"\") This function does the same as the by_name function but for the socket type. It will give you the code for all sockets with the type of the socket you call it on node. list_code(value_list, indents=0) If the two functions above don't work for you for some reason, you can use this function to achieve the same with any given code. You pass it a list of strings which represent your code and give it the indents that your code should have","title":"Socket Code"},{"location":"developers/node_draw/","text":"Draw node To draw properties and other things on your node these functions should help you: draw_node(self, context, layout) This function is the main draw function for the node. You can use it to display properties or other things on your node draw_node_panel(self, context, layout) This function is used to draw additional elements in the N-Panel that are not displayed on your node itself. Serpens constrains the UI to the node for all internal nodes but you can use this for packages. You might want to inform the user in some form that you are using the N-Panel as this is not a Serpens standard","title":"Draw Node"},{"location":"developers/node_draw/#draw-node","text":"To draw properties and other things on your node these functions should help you: draw_node(self, context, layout) This function is the main draw function for the node. You can use it to display properties or other things on your node draw_node_panel(self, context, layout) This function is used to draw additional elements in the N-Panel that are not displayed on your node itself. Serpens constrains the UI to the node for all internal nodes but you can use this for packages. You might want to inform the user in some form that you are using the N-Panel as this is not a Serpens standard","title":"Draw node"},{"location":"developers/node_events/","text":"Event Functions These are functions that you can overwrite in your node. They are called on certain events and meant for handling different things: on_create(self, context) This function is called when the node is created. You should add your initial sockets here on_copy(self, node) This function is called when the node is copied. Reset properties here if you need to. It gives you the newly created node which you should use instead of self in this function on_free(self) This function is called when this node is deleted on_node_update(self) This function is called when this node is updated in any way, for example when sockets get connected on_link_insert(self, link) This function is called when a link is inserted, meaning when another socket is connected to this node. It gives you the newly created link. Contrary to the normal python function for link updates it is called with a slight delay so that you can use this link normally on_any_change(self) This is called every time before the auto compile function is called on_outside_update(self, node) This function is the one that is called when update_nodes_by_type is called for this node type. It gives you the node which this function was initiated from on_dynamic_add(self, socket, connected_socket) This function is called when a dynamic socket is added to this node. You're given the socket that was created as well as the socket that is connected. This can be None if the dynamic socket was added with the add button instead of connecting another node on_dynamic_remove(self, is_output) This function is called when a removable socket has been removed. It gives you a boolean which defines if the removed socket was an output on_var_name_update(self, socket) This function is called when the variable name of a socket is changed Update Functions These are functions which you can use to update nodes: auto_compile(self, context) This function is needed to make your node work with the compiler and to register any changes you're making. Make sure to call this function as the update function for node properties and in other cases where you update your node internally and the user needs to recompile update_nodes_by_type(self, idname) This function is used to update every node with the given idname. It calls on_outside_update on these nodes update_nodes_by_types(self, idname_list) This function is like the one above but takes a list of idnames","title":"Events"},{"location":"developers/node_events/#event-functions","text":"These are functions that you can overwrite in your node. They are called on certain events and meant for handling different things: on_create(self, context) This function is called when the node is created. You should add your initial sockets here on_copy(self, node) This function is called when the node is copied. Reset properties here if you need to. It gives you the newly created node which you should use instead of self in this function on_free(self) This function is called when this node is deleted on_node_update(self) This function is called when this node is updated in any way, for example when sockets get connected on_link_insert(self, link) This function is called when a link is inserted, meaning when another socket is connected to this node. It gives you the newly created link. Contrary to the normal python function for link updates it is called with a slight delay so that you can use this link normally on_any_change(self) This is called every time before the auto compile function is called on_outside_update(self, node) This function is the one that is called when update_nodes_by_type is called for this node type. It gives you the node which this function was initiated from on_dynamic_add(self, socket, connected_socket) This function is called when a dynamic socket is added to this node. You're given the socket that was created as well as the socket that is connected. This can be None if the dynamic socket was added with the add button instead of connecting another node on_dynamic_remove(self, is_output) This function is called when a removable socket has been removed. It gives you a boolean which defines if the removed socket was an output on_var_name_update(self, socket) This function is called when the variable name of a socket is changed","title":"Event Functions"},{"location":"developers/node_events/#update-functions","text":"These are functions which you can use to update nodes: auto_compile(self, context) This function is needed to make your node work with the compiler and to register any changes you're making. Make sure to call this function as the update function for node properties and in other cases where you update your node internally and the user needs to recompile update_nodes_by_type(self, idname) This function is used to update every node with the given idname. It calls on_outside_update on these nodes update_nodes_by_types(self, idname_list) This function is like the one above but takes a list of idnames","title":"Update Functions"},{"location":"developers/node_functions/","text":"Node Functions These are functions that are also important for you to work with. They are split into different categories: Compiler functions These are functions that you can call from your node which are required for the compiling to work: auto_compile(self, context) This function is needed to make your node work with the compiler and to register any changes you're making. Make sure to call this function as the update function for node properties and in other cases where you update your node internally and the user needs to recompile. The function is part of your node add_error(self, title, description, fatal=False) This function is used to add errors to the error panel. These should be shown when there are things the user didn't do properly and which should cause an error. These are not shown in the system console and should always be preferred over real python errors. It is an opportunity for you to improve the experience of the user with debugging. The function takes a title, a description and a boolean for defining if the error was fatal. A fatal error is something that is fundamentally different from what the user expected to happen. Fatal errors will cause a popup to appear informing the user of the error. This function is also part of your node Related node information Sometimes you need to get information about connected nodes. These functions can help you with that: what_layout(self, socket) This function is used for Interface nodes only. It returns a string which helps you get the layout type that the previous node is using. This could for example be a panel which returns `layout or a row returning row or a split interface node returning split . You use it to put your layouts in the right place, so for example {YOUR_LAYOUT}.label(text=\"\") where you would get YOUR_LAYOUT with this function what_start_idname(self) This will give you the idname of the node starting your node tree. This only works with execute and interface sockets. The function will try to follow these sockets until it finds the first node in the tree and give you the idname what_start_node(self) This acts the same way the function above does but gives you the start node instead of its idname Unique names Sometimes you need unique names or python compatible names. These are functions to help you with that: get_python_name(self, name, empty_name=\"\") This is a function for making any text into a valid python name. This can then be used as a variable name, a function name, etc.. The empty name is what is used if the provided name is empty or equates to empty when it's made into a valid python name get_unique_name(self, name, collection, separator=\"_\") This gives you a unique name for a given collection property or list of strings. It will try to increment a number at the end of the name if it finds one. If it doesn't, it will use the separator and add a number get_unique_python_name(self, name, empty_name, collection, separator=\"_\") This is a combination of the two functions above which will give you a unique python name Node Collections These are functions which you can use to access the node collections. These are related to the has_collection parameter in the node options. In general collections are stored in the addon tree and accessible from nodes with self.addon_tree.sn_nodes[node_idname] . This gives you a property group with a name and items. The items are a collection property which hold all node items with that idname. These have a name , the node_uid and a function called node() to get the actual node belonging to the item: collection This is a property function (call it like a property on the node) which returns the collection for this node. It is a shortcut for self.addon_tree.sn_nodes[self.bl_idname] item This is a property function which returns this nodes item from the collection for this node add_required_to_collection(self, idname_list) This should be used in on_create to set up nodes collections if you need to access them. An example is the run operator node which adds a collection for the operator node as it needs to use a prop_search to find operator nodes. Collections are automatically created when a node is added but if none of the required type have been added yet this collection won't exist","title":"Node Functions"},{"location":"developers/node_functions/#node-functions","text":"These are functions that are also important for you to work with. They are split into different categories:","title":"Node Functions"},{"location":"developers/node_functions/#compiler-functions","text":"These are functions that you can call from your node which are required for the compiling to work: auto_compile(self, context) This function is needed to make your node work with the compiler and to register any changes you're making. Make sure to call this function as the update function for node properties and in other cases where you update your node internally and the user needs to recompile. The function is part of your node add_error(self, title, description, fatal=False) This function is used to add errors to the error panel. These should be shown when there are things the user didn't do properly and which should cause an error. These are not shown in the system console and should always be preferred over real python errors. It is an opportunity for you to improve the experience of the user with debugging. The function takes a title, a description and a boolean for defining if the error was fatal. A fatal error is something that is fundamentally different from what the user expected to happen. Fatal errors will cause a popup to appear informing the user of the error. This function is also part of your node","title":"Compiler functions"},{"location":"developers/node_functions/#related-node-information","text":"Sometimes you need to get information about connected nodes. These functions can help you with that: what_layout(self, socket) This function is used for Interface nodes only. It returns a string which helps you get the layout type that the previous node is using. This could for example be a panel which returns `layout or a row returning row or a split interface node returning split . You use it to put your layouts in the right place, so for example {YOUR_LAYOUT}.label(text=\"\") where you would get YOUR_LAYOUT with this function what_start_idname(self) This will give you the idname of the node starting your node tree. This only works with execute and interface sockets. The function will try to follow these sockets until it finds the first node in the tree and give you the idname what_start_node(self) This acts the same way the function above does but gives you the start node instead of its idname","title":"Related node information"},{"location":"developers/node_functions/#unique-names","text":"Sometimes you need unique names or python compatible names. These are functions to help you with that: get_python_name(self, name, empty_name=\"\") This is a function for making any text into a valid python name. This can then be used as a variable name, a function name, etc.. The empty name is what is used if the provided name is empty or equates to empty when it's made into a valid python name get_unique_name(self, name, collection, separator=\"_\") This gives you a unique name for a given collection property or list of strings. It will try to increment a number at the end of the name if it finds one. If it doesn't, it will use the separator and add a number get_unique_python_name(self, name, empty_name, collection, separator=\"_\") This is a combination of the two functions above which will give you a unique python name","title":"Unique names"},{"location":"developers/node_functions/#node-collections","text":"These are functions which you can use to access the node collections. These are related to the has_collection parameter in the node options. In general collections are stored in the addon tree and accessible from nodes with self.addon_tree.sn_nodes[node_idname] . This gives you a property group with a name and items. The items are a collection property which hold all node items with that idname. These have a name , the node_uid and a function called node() to get the actual node belonging to the item: collection This is a property function (call it like a property on the node) which returns the collection for this node. It is a shortcut for self.addon_tree.sn_nodes[self.bl_idname] item This is a property function which returns this nodes item from the collection for this node add_required_to_collection(self, idname_list) This should be used in on_create to set up nodes collections if you need to access them. An example is the run operator node which adds a collection for the operator node as it needs to use a prop_search to find operator nodes. Collections are automatically created when a node is added but if none of the required type have been added yet this collection won't exist","title":"Node Collections"},{"location":"developers/node_options/","text":"Node Options The node options tell Serpens what properties this node should have and how it should be treated when compiling. You only need to add the parameters to the node options that you actually want to change. You can see the defaults here: node_options = { \"default_color\": (0.3,0.3,0.3), \"starts_tree\": False, \"register_order\": 0, \"has_collection\": False, \"collection_name_attr\": \"name\", \"import_once\": True, \"evaluate_once\": False, \"register_once\": False, \"unregister_once\": False, \"imperative_once\": False } default_color This is a tuple of three values from 0-1 which sets the default color of the node starts_tree This defines if this node should be treated as the beginning of a node branch. This is True for nodes like Panel, Operator, Function, etc. register_order This changes the order in which nodes are registered. If you need a certain custom node to be registered before another set this value. Nodes with a lower number will be registered first. For unregister the order will be inverted has_collection If this is true there will be an automatically created collection which holds all nodes of this type. This is used in nodes like Run Operator where you need to be able to select one of the nodes in your node tree of a certain type. How you can access these collections will be explained below collection_name_attr This is the attribute that your node will be shown with in your collection. By default this is the name of the node, meaning if you have a prop_search for selecting a node, the items will be named with the names of the nodes. The panel node for example has a string property named label which is also used for this property import_once If this is True, the code_imports function will only be called once for this node type in all node trees evaluate_once If this is True, the code_evaluate function will only be called once for this node type in all node trees register_once If this is True, the code_register function will only be called once for this node type in all node trees unregister_once If this is True, the code_unregister function will only be called once for this node type in all node trees imperative_once If this is True, the code_imperative function will only be called once for this node type in all node trees Node Properties Serpens nodes have certain properties that can be useful in development: uid This is a unique identifier for this node. You might sometimes want to use this to make sure your generated python names node_tree This is the node tree your node is currently in. You can use this at all times in your code addon_tree Because Serpens addons consist of multiple node trees you sometimes need to access the main node tree. It stores information about the addon itself and is generally used as a starting point for some things. You can access it at all times with this property prop_types This is a dictionary with property types as keys. It will give you the matching socket type idname. An example would be self.prop_types[\"BOOLEAN\"] which would give you \"SN_BooleanSocket\"","title":"Node Options"},{"location":"developers/node_options/#node-options","text":"The node options tell Serpens what properties this node should have and how it should be treated when compiling. You only need to add the parameters to the node options that you actually want to change. You can see the defaults here: node_options = { \"default_color\": (0.3,0.3,0.3), \"starts_tree\": False, \"register_order\": 0, \"has_collection\": False, \"collection_name_attr\": \"name\", \"import_once\": True, \"evaluate_once\": False, \"register_once\": False, \"unregister_once\": False, \"imperative_once\": False } default_color This is a tuple of three values from 0-1 which sets the default color of the node starts_tree This defines if this node should be treated as the beginning of a node branch. This is True for nodes like Panel, Operator, Function, etc. register_order This changes the order in which nodes are registered. If you need a certain custom node to be registered before another set this value. Nodes with a lower number will be registered first. For unregister the order will be inverted has_collection If this is true there will be an automatically created collection which holds all nodes of this type. This is used in nodes like Run Operator where you need to be able to select one of the nodes in your node tree of a certain type. How you can access these collections will be explained below collection_name_attr This is the attribute that your node will be shown with in your collection. By default this is the name of the node, meaning if you have a prop_search for selecting a node, the items will be named with the names of the nodes. The panel node for example has a string property named label which is also used for this property import_once If this is True, the code_imports function will only be called once for this node type in all node trees evaluate_once If this is True, the code_evaluate function will only be called once for this node type in all node trees register_once If this is True, the code_register function will only be called once for this node type in all node trees unregister_once If this is True, the code_unregister function will only be called once for this node type in all node trees imperative_once If this is True, the code_imperative function will only be called once for this node type in all node trees","title":"Node Options"},{"location":"developers/node_options/#node-properties","text":"Serpens nodes have certain properties that can be useful in development: uid This is a unique identifier for this node. You might sometimes want to use this to make sure your generated python names node_tree This is the node tree your node is currently in. You can use this at all times in your code addon_tree Because Serpens addons consist of multiple node trees you sometimes need to access the main node tree. It stores information about the addon itself and is generally used as a starting point for some things. You can access it at all times with this property prop_types This is a dictionary with property types as keys. It will give you the matching socket type idname. An example would be self.prop_types[\"BOOLEAN\"] which would give you \"SN_BooleanSocket\"","title":"Node Properties"},{"location":"developers/node_sockets/","text":"Node Sockets def on_create(self,context): self.add_execute_input(\"Execute\") self.add_boolean_input(\"Boolean\") self.add_execute_output(\"Execute\").mirror_name = True To set up the basic sockets of your node, add them in on_create . The functions for adding inputs and outputs are all based on the node, meaning you can call them with self.add_TYPE_SOCKET(\"My Socket\") where TYPE is the type of the socket you're adding and SOCKET is either input or output. There are functions for all different socket types. Some of them are also dynamic, which means that they are placeholders until another socket is connected or the add button is pressed which will add another socket with the same type and name before it. Each of the following functions is called on the node and takes in the name of the socket as a parameter. They all return the socket they create: add_interface_input/add_interface_output/add_dynamic_interface_input/add_dynamic_interface_output [Interface] add_execute_input/... [Execute] add_string_input/... [String] add_boolean_input/... [Boolean] add_float_input/... [Float] add_integer_input/... [Integer] add_data_input/... [Data] add_list_input/... [List] add_dynamic_variable_input/add_dynamic_variable_output [Variable] add_icon_input/add_icon_output [Icon] add_blend_data_input/add_blend_data_output [Blend Data] To remove sockets simply use self.inputs.remove(input) or self.outputs.remove(output) . Socket Properties The functions return the socket which allows you to set a bunch of parameters depending on the socket type: group [All socket types, readonly] (str) Set to DATA for all socketes except for Interface and Execute where it is PROGRAM socket_type [All socket types, readonly] (str) The type of the socket subtype [All socket types] (str) The subtype of the socket. This is different for each type of socket: String (NONE, FILE, DIRECTORY, ENUM) Boolean (NONE, VECTOR3, VECTOR4) Float (NONE, FACTOR, COLOR, COLOR_ALPHA, VECTOR3, VECTOR4) Integer (NONE, VECTOR3, VECTOR4) Blend Data (NONE, COLLECTION) dynamic [All socket types, readonly] (boolean) Boolean that tells you if the socket is dynamic copy_socket [All socket types] (boolean) Boolean that tells you if the dynamic socket should copy all of the properties when a socket is connected. This includes type, name, etc. removable [All socket types] (boolean) Boolean that defines if this socket shows a remove button addable [All socket types, readonly] (boolean) Boolean that defines if this socket shows an add button for adding another socket of this type to_add_idname [All socket types, readonly] (string) Required if addable or dynamic is true. Should be set to the idname that is added by this socket disableable [All socket types] (boolean) Shows an eye icon on the socket to disable this socket enabled [All socket types] (boolean) Enables or disables the socket. You can check this in your code functions default_text [All socket types] (string) The displayed text of this socket. Use this instead of name mirror_name [All socket types] (boolean) Mirrors the name of the connected socket if this is enabled. This is purely visual. Execute outputs should mirror the name of the connected socket and so should interface inputs take_name [All socket types] (boolean) Makes this socket take over the name of the socket that is first connected to this socket variable_name [All socket types] (string) The variable name of this socket. This property is used by the variable properties below return_var_name [All socket types] (boolean) Skips the code functions for this socket and just returns the variable name instead show_var_name [All socket types] (boolean) Shows the variable name on the socket edit_var_name [All socket types] (boolean) If enabled together with show_var_name, the variable name can be edited on the socket data_type [Blend Data] (string) Should be set to the data type of this socket. This is something from bpy.types data_name [Blend Data] (string) Should be set to the name of this sockets data type data_identifier [Blend Data] (string) Optional property that can be set to the identifier of this blend data type enum_values [String] (string) The enum items if this string is an enum subtype. This should be in the format of \"[(\"ITEM\",\"name\",\"description\"),]\" Socket Utility Functions With this you should be able to add sockets. You can also manipulate your sockets after the node is added. There's a bunch of functions which help you with that: add_input_from_prop(self, prop) - return input Takes in a property like StringProperty, BoolProperty, etc. and creates a socket with the proper type and name add_output_from_prop(self, prop) - return output See add_input_from_prop enum_items_as_string(self, enum_prop) - return string Gives you a string which you can set your enum_values of a string socket from an enum property change_socket_type(self, socket, idname) - return socket Takes a socket and an idname. It changes the socket type to the given idname but keeps the connections remove_output_range(self, start_index, end_index=-1) Removes all outputs from the start index to the end index remove_input_range(self, start_index, end_index=-1) Removes all inputs from the start index to the end index","title":"Sockets"},{"location":"developers/node_sockets/#node-sockets","text":"def on_create(self,context): self.add_execute_input(\"Execute\") self.add_boolean_input(\"Boolean\") self.add_execute_output(\"Execute\").mirror_name = True To set up the basic sockets of your node, add them in on_create . The functions for adding inputs and outputs are all based on the node, meaning you can call them with self.add_TYPE_SOCKET(\"My Socket\") where TYPE is the type of the socket you're adding and SOCKET is either input or output. There are functions for all different socket types. Some of them are also dynamic, which means that they are placeholders until another socket is connected or the add button is pressed which will add another socket with the same type and name before it. Each of the following functions is called on the node and takes in the name of the socket as a parameter. They all return the socket they create: add_interface_input/add_interface_output/add_dynamic_interface_input/add_dynamic_interface_output [Interface] add_execute_input/... [Execute] add_string_input/... [String] add_boolean_input/... [Boolean] add_float_input/... [Float] add_integer_input/... [Integer] add_data_input/... [Data] add_list_input/... [List] add_dynamic_variable_input/add_dynamic_variable_output [Variable] add_icon_input/add_icon_output [Icon] add_blend_data_input/add_blend_data_output [Blend Data] To remove sockets simply use self.inputs.remove(input) or self.outputs.remove(output) .","title":"Node Sockets"},{"location":"developers/node_sockets/#socket-properties","text":"The functions return the socket which allows you to set a bunch of parameters depending on the socket type: group [All socket types, readonly] (str) Set to DATA for all socketes except for Interface and Execute where it is PROGRAM socket_type [All socket types, readonly] (str) The type of the socket subtype [All socket types] (str) The subtype of the socket. This is different for each type of socket: String (NONE, FILE, DIRECTORY, ENUM) Boolean (NONE, VECTOR3, VECTOR4) Float (NONE, FACTOR, COLOR, COLOR_ALPHA, VECTOR3, VECTOR4) Integer (NONE, VECTOR3, VECTOR4) Blend Data (NONE, COLLECTION) dynamic [All socket types, readonly] (boolean) Boolean that tells you if the socket is dynamic copy_socket [All socket types] (boolean) Boolean that tells you if the dynamic socket should copy all of the properties when a socket is connected. This includes type, name, etc. removable [All socket types] (boolean) Boolean that defines if this socket shows a remove button addable [All socket types, readonly] (boolean) Boolean that defines if this socket shows an add button for adding another socket of this type to_add_idname [All socket types, readonly] (string) Required if addable or dynamic is true. Should be set to the idname that is added by this socket disableable [All socket types] (boolean) Shows an eye icon on the socket to disable this socket enabled [All socket types] (boolean) Enables or disables the socket. You can check this in your code functions default_text [All socket types] (string) The displayed text of this socket. Use this instead of name mirror_name [All socket types] (boolean) Mirrors the name of the connected socket if this is enabled. This is purely visual. Execute outputs should mirror the name of the connected socket and so should interface inputs take_name [All socket types] (boolean) Makes this socket take over the name of the socket that is first connected to this socket variable_name [All socket types] (string) The variable name of this socket. This property is used by the variable properties below return_var_name [All socket types] (boolean) Skips the code functions for this socket and just returns the variable name instead show_var_name [All socket types] (boolean) Shows the variable name on the socket edit_var_name [All socket types] (boolean) If enabled together with show_var_name, the variable name can be edited on the socket data_type [Blend Data] (string) Should be set to the data type of this socket. This is something from bpy.types data_name [Blend Data] (string) Should be set to the name of this sockets data type data_identifier [Blend Data] (string) Optional property that can be set to the identifier of this blend data type enum_values [String] (string) The enum items if this string is an enum subtype. This should be in the format of \"[(\"ITEM\",\"name\",\"description\"),]\"","title":"Socket Properties"},{"location":"developers/node_sockets/#socket-utility-functions","text":"With this you should be able to add sockets. You can also manipulate your sockets after the node is added. There's a bunch of functions which help you with that: add_input_from_prop(self, prop) - return input Takes in a property like StringProperty, BoolProperty, etc. and creates a socket with the proper type and name add_output_from_prop(self, prop) - return output See add_input_from_prop enum_items_as_string(self, enum_prop) - return string Gives you a string which you can set your enum_values of a string socket from an enum property change_socket_type(self, socket, idname) - return socket Takes a socket and an idname. It changes the socket type to the given idname but keeps the connections remove_output_range(self, start_index, end_index=-1) Removes all outputs from the start index to the end index remove_input_range(self, start_index, end_index=-1) Removes all inputs from the start index to the end index","title":"Socket Utility Functions"},{"location":"developers/nodes/","text":"Creating A Node Below you can find an empty example node which you can copy to quickly get started. In theory you could put multiple nodes into one file, but we don't recommend doing that to keep your files better organized. Example Node Copy this code to get a base for your own nodes: import bpy from ...node_tree.base_node import SN_ScriptingBaseNode class SN_MyNode(bpy.types.Node, SN_ScriptingBaseNode): bl_idname = \"SN_MyNode\" bl_label = \"My Node\" bl_width_default = 160 node_options = { \"default_color\": (0.3,0.3,0.3), } def on_create(self,context): self.add_execute_input(\"Execute\") self.add_boolean_input(\"Boolean\") self.add_execute_output(\"Execute\").mirror_name = True def draw_node(self, context, layout): layout.label(text=\"My Node Label\") def code_evaluate(self, context, touched_socket): return { \"code\": f\"\"\" print({self.inputs[\"Boolean\"].code()}) {self.outputs[0].code(5)} \"\"\" }","title":"Basics"},{"location":"developers/nodes/#creating-a-node","text":"Below you can find an empty example node which you can copy to quickly get started. In theory you could put multiple nodes into one file, but we don't recommend doing that to keep your files better organized.","title":"Creating A Node"},{"location":"developers/nodes/#example-node","text":"Copy this code to get a base for your own nodes: import bpy from ...node_tree.base_node import SN_ScriptingBaseNode class SN_MyNode(bpy.types.Node, SN_ScriptingBaseNode): bl_idname = \"SN_MyNode\" bl_label = \"My Node\" bl_width_default = 160 node_options = { \"default_color\": (0.3,0.3,0.3), } def on_create(self,context): self.add_execute_input(\"Execute\") self.add_boolean_input(\"Boolean\") self.add_execute_output(\"Execute\").mirror_name = True def draw_node(self, context, layout): layout.label(text=\"My Node Label\") def code_evaluate(self, context, touched_socket): return { \"code\": f\"\"\" print({self.inputs[\"Boolean\"].code()}) {self.outputs[0].code(5)} \"\"\" }","title":"Example Node"},{"location":"developers/setup/","text":"Setup Development Setup To actually get started developing we have a few recommendations. To work on a node you want to add to your package, you'll need to temporarily add it to the addon itself. Start by finding the folder where you have installed the visual scripting addon. You can find this in the user preferences in the addons panel under File . Inside the main Serpens folder you'll find a folder called nodes. This is the folder you'll work in. When you open up the folder you will find the directories corresponding to the node categories, as mentioned in the introduction. These are the installed categories and nodes. When a user installs your package, the zip files content will go in here. You don't need to and can't touch any of the other files in any of the addons folders. You only create your nodes in the corresponding folder for development and then put them in the zip file for distribution. To create a new category during development, you create a subfolder in nodes with the corresponding name. Now you need to add a file called __init__.py in that folder. This is for blender to recognize it as a part of the addon, which can be left empty. Note that you need to add this file in your final .zip if you are creating a new category. If you only add nodes to an existing category don't add the file. Your new category should then look something like in the image above. If you just want to add a node in an existing category you only need to add your .py file for the node itself in the existing folder. You can have new categories and add nodes to existing ones in one package. Note that empty categories will not be shown, meaning you need to create a node first for it to show up in blenders add menu. Summary You should now know how to set up your editor of choice for developing your package. We use VS Code together with Jacques Lucke's Blender Development extension . Start by creating a file for a node in a new or existing category. We will now continue with developing a node. Later we will get into how to distribute your package in the mentioned zip file once you are done with development.","title":"Setup"},{"location":"developers/setup/#setup","text":"","title":"Setup"},{"location":"developers/setup/#development-setup","text":"To actually get started developing we have a few recommendations. To work on a node you want to add to your package, you'll need to temporarily add it to the addon itself. Start by finding the folder where you have installed the visual scripting addon. You can find this in the user preferences in the addons panel under File . Inside the main Serpens folder you'll find a folder called nodes. This is the folder you'll work in. When you open up the folder you will find the directories corresponding to the node categories, as mentioned in the introduction. These are the installed categories and nodes. When a user installs your package, the zip files content will go in here. You don't need to and can't touch any of the other files in any of the addons folders. You only create your nodes in the corresponding folder for development and then put them in the zip file for distribution. To create a new category during development, you create a subfolder in nodes with the corresponding name. Now you need to add a file called __init__.py in that folder. This is for blender to recognize it as a part of the addon, which can be left empty. Note that you need to add this file in your final .zip if you are creating a new category. If you only add nodes to an existing category don't add the file. Your new category should then look something like in the image above. If you just want to add a node in an existing category you only need to add your .py file for the node itself in the existing folder. You can have new categories and add nodes to existing ones in one package. Note that empty categories will not be shown, meaning you need to create a node first for it to show up in blenders add menu.","title":"Development Setup"},{"location":"developers/setup/#summary","text":"You should now know how to set up your editor of choice for developing your package. We use VS Code together with Jacques Lucke's Blender Development extension . Start by creating a file for a node in a new or existing category. We will now continue with developing a node. Later we will get into how to distribute your package in the mentioned zip file once you are done with development.","title":"Summary"}]}