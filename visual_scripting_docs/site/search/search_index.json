{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This is the documentation for developing packages for the Serpens - Visual Scripting Addon. It is not a documentation on how to use the addon, that is built in. Content This documentation goes over creating nodes in specific categories. It will give you an overview of the different functions you need to work with. It also explains how to distribute your packages to others.","title":"Introduction"},{"location":"#introduction","text":"This is the documentation for developing packages for the Serpens - Visual Scripting Addon. It is not a documentation on how to use the addon, that is built in.","title":"Introduction"},{"location":"#content","text":"This documentation goes over creating nodes in specific categories. It will give you an overview of the different functions you need to work with. It also explains how to distribute your packages to others.","title":"Content"},{"location":"bugs/","text":"Important! Whatever you do, please don't report your issue in the ratings of the addon . That doesn't help anyone and is just annoying for us as we really depend on those. It also doesn't help you because we can't really respond and help you there . (I wish I didn't have to put this here, but it happens unfortunately) Report a bug Please provide the following information when reporting a bug: A short description of the issue Node causing the issue A screenshot of the error message if existing Addon version Blender version Your operating system List of installed packages (screenshot is fine) You can copy the following template and replace the information relevant to your issue. If you think something is absolutely not related to your problem then just don't add it, we will ask you if we think it is. Try to add as much information as you can, that way we can help you the fastest: Info: # operating system here # blender version here # addon version here Description: # node causing the issue here # short description here Assets: # list of installed packages here # error message screenshot here Contact You can report your issue on any of the following platforms. They are ordered in how fast we can respond (at least most of the time): - Discord - Twitter - Blenderartists - Blendermarket","title":"Bugs"},{"location":"bugs/#report-a-bug","text":"Please provide the following information when reporting a bug: A short description of the issue Node causing the issue A screenshot of the error message if existing Addon version Blender version Your operating system List of installed packages (screenshot is fine) You can copy the following template and replace the information relevant to your issue. If you think something is absolutely not related to your problem then just don't add it, we will ask you if we think it is. Try to add as much information as you can, that way we can help you the fastest: Info: # operating system here # blender version here # addon version here Description: # node causing the issue here # short description here Assets: # list of installed packages here # error message screenshot here","title":"Report a bug"},{"location":"bugs/#contact","text":"You can report your issue on any of the following platforms. They are ordered in how fast we can respond (at least most of the time):","title":"Contact"},{"location":"bugs/#-discord","text":"","title":"- Discord"},{"location":"bugs/#-twitter","text":"","title":"- Twitter"},{"location":"bugs/#-blenderartists","text":"","title":"- Blenderartists"},{"location":"bugs/#-blendermarket","text":"","title":"- Blendermarket"},{"location":"developers/create_node/","text":"Creating A Node At the end of this page, you can find an empty example node which you can copy to quickly get started. In theory you could put multiple nodes into one file, but we don't recommend doing that to keep your files better organized. Setup You start by noting down the idnames of the nodes you want to create. This should be in the first lines of your file and written as a comment. Without this the addon will not find your node. We will use the print nodes structure as an example: #SN_PrintNode Imports After this, there are a few imports that we require. This includes the bpy module as well as the basic visual scripting node class. The imports look as follows: import bpy from ...node_tree.base_node import SN_ScriptingBaseNode Node Class Now you can get to your actual node class. Be aware that you could also add things like property groups or operators inbetween here, if that is something that your node requires. class SN_PrintNode(bpy.types.Node, SN_ScriptingBaseNode): # required bl_idname = \"SN_PrintNode\" bl_label = \"Print\" bl_icon = \"CONSOLE\" # optional bl_width_min = 40 bl_width_default = 160 bl_width_max = 5000 node_color = (0.2, 0.2, 0.2) should_be_registered = False min_blender_version = (2,83,0) serpens_versions = None docs = { \"text\": [\"The print node is used to <important>write things to the console</>.\", \"\", \"Value Inputs: <subtext>What is connected here will be printed.\", \"<subtext> This can be any type of data like </>numbers, strings, etc.\"], \"python\": [\"<function>print</>( <string>\\\"my example\\\"</>, <number>123</>, <string>\\\"test\\\"</> )\"] } To create your node, add a class with the name you specified at the top of your file. The class should inherit from bpy.types.Node and the base node you imported. You can treat this as a normal blender python class, meaning you can add properties and functions to it. Attributes bl_idname : The idname of your node. This needs to be the same as the class name and the name at the top of your file. bl_label : The label shown in the node categories and in the nodes header. bl_icon : The name of the icon that your node shows in it's header. bl_width_min : The minimum width of your node. bl_width_default : The default width of your node. bl_width_max : The maximum width of your node. node_color : This is the color of your node. Make sure to keep these pleasing for the eye and consistent between node types. should_be_registered : This is a very important argument as it determines if the node should be registered or not. We will go over this again below. serpens_versions : This is an optional parameter for providing versions of Serpens that this node is compatible with. You need to list all versions here. Changes that could affect your node are marked with changes in the first two numbers (x,x,-) . The last one is for bugfixes, etc.. The parameter is given in the format [(x,x),(x,x),...] where the x's are the first two numbers of the addon version. The default is None which allows for all versions. You can get the addon version by calling get_serpens_version in your node min_blender_version : This is the minimum required blender version for this node. If it isn't above this version it will return empty code and an error. Make sure to provide the version in the format of bpy.app.version : (x,xx,x) docs : This is the documentation for your node. It will be explained below as well. should_be_registered As mentioned before, when the node tree is compiled, the addon goes through the tree and evaluates the nodes one by one. To find the nodes to start at you use this attribute. If it is true it is a node that the addon starts from. This is the case for nodes like 'Create Operator' or 'Panel'. docs This holds the documentation for that node. It will be shown if the documentation overlay is enabled. The dictionary is split into text and python . \"text\" should explain the function of the node and what the different inputs do. Please do not just repeat the basics here, but make note of things that are specific to this node. \"python\" should hold the python equivalent of your node if possible. Both attributes need to be lists of strings, where one string represents one line. They can be left empty but both lists need to be there. You can use color formatting on your strings. This works by wrapping the text you want to color in tags. The start of a color is marked with <color_name> . The color can be one of these: [serpens, subtext, important, function, number, string, data, red, blue, green, orange, yellow, grey, lightgrey, black] or just a color in the form <(0.2, 0.3, 0.4)> . To mark the end of a colored section, use <\\> . This way you can format your python code and also mark important parts of your documentation text. These are the attributes that you need to and can set for your node. Next we will cover the functions. Functions You can overwrite these functions in your node to make it actually do something: initialize(self, context) This is the function that is called once when the node is created. Here you should add the inputs and outputs to your node and initialize any other values. You can add an inputs and outputs like this: def inititialize(self, context): self.sockets.create_input(self,\"EXECUTE\",\"Execute\") self.sockets.create_input(self,\"DATA\",\"Value\") self.sockets.create_output(self,\"EXECUTE\",\"Execute\") As you can see, you need to call functions from self.sockets, which handles the nodes sockets. You can find them here . evaluate(self, socket, node_data, errors) This is the most important function in your node, as it is what the addon calls to get the generated python code. This needs to return a dictionary in a specific form for this to work. def evaluate(self, socket, node_data, errors): return { \"blocks\": [ { \"lines\": [ [\"line\",\" 1\"], [\"line 2\"] ], \"indented\": [ [\"indented line\",\" 1\"], [\"indented line 2\"], { \"lines\": [ [\"code in nested code block\"] ], \"indented\": [ [\"double indented code\"] ] } ] } ], \"errors\": errors } The evaluate function needs to return a dictionary with two keys. The first is \"blocks\" which contains the actual generated python code. This is a list of code blocks. A code block is a dictionary with two keys. Those are \"lines\" and \"indented\" . Both are lists which hold lines of code. One line is a list of strings and sockets. That means that you can separate parts of the line with commas. If you have a socket in one of your lines, the node of that socket will be evaluated and the code will be added to that line. If you know that the sockets node will return multiple lines just use a list with only that socket, it will then be adjusted accordingly to add those lines. An example would be the print node where you have a line like [\"print(\", socket, \")\"] . The socket is the socket that is connected to the input of the print node. While you could check what sockets are connected yourself, we provide the node_data for evaluate. This is a dictionary containing \"input_data\" , \"output_data\" and \"node_tree\" . Node Tree is the tree, the node lives in. Input and Output data are lists. They contain one dictionary for each input/output your node has in the order they appear. Those dictionaries have the following data: socket : The socket that this dictionaries data belongs to. name : The name of the socket. value : The value of the socket. This is always a string and is the actual value entered in the socket. For a integer socket this could be '5'. connected : This is None if there is nothing connected to the socket or the connected socket. This can be used as a part of a line. code : This is the combination of value and connected. If there is no node connected to the socket it is equal to value , if there is a valid socket connected it is equal to connected . Most of the time you can use the code parameter in your lines to return the sockets value. For the print node example this would be [\"print(\", node_data[\"input_data\"][1][\"code\"], \")\"] . The \"indented\" list works the same as the \"lines\" list, but they come after the lines and are one step indented. It is important to know that you can nest code blocks. This means you can put code blocks (dictionaries with lines and indented lists) in the lists instead of a line. You can see this better in the example above. This way you can create more complicated indents and nesting in your generated code. Make sure you understand this structure before starting your nodes as it is very important for proper generated code. Finally the dictionary returned by evaluate also contains a key called \"errors\" . This is a list of errors that are related to this node. This could be a socket that is connected to something it shouldn't be or a name that hasn't been set properly. These errors will be displayed in the N-Panel. It is important that you actually make use of these and not just let the error trickle down to the actual python code. Make sure to always have default alternatives for these errors, so you can still return working code. Errors is a list of dictionaries, where each dictionary is an error. It has the following keys: title : The title of the error message. message : The content of the error message. node : The node the error came from. This is usually self . fatal : True or False, depending on if the error completely changes how the addon behaves or is just a minor issue that doesn't affect much. There is a list of errors provided as a parameter for evaluate. This contains errors coming from wrongly connected sockets. While you should use these, you can of course add your own errors if you have more specialized cases. Another parameter passed to the evaluate function is socket . This is the socket that your node got evaluated from. If you have a node that needs to return different things depending on what socket it's called from then you need to use this. If your node is being called because it's being registered this will be None. The evaluate function is where you will probably spend most of the time and where most of your code lives. Make sure to organize it properly and split some of the things in other functions to be able to properly keep track of errors. Again, it's important that the user doesn't have to deal with actual python errors. This addon is not about generating the most efficient code, but to provide the best user experience when making addons with no coding knowledge. draw_buttons(self, context, layout) Here you can draw additional layouts on your node. This will be shown at the top of your nodes and can include anything you can put in a blender ui layout. def draw_buttons(self, context, layout): layout.label(text=\"My label\") layout.prop(self,\"my_node_property\") You can also draw an icon selector here by calling self.draw_icon_chooser(layout) . The chosen icon name can then be accessed with self.icon anywhere in your node. get_register_block(self) If your node has should_be_registered set to True, it needs to provide code that is added to the register function. The function returns a list where every string is one line. def get_register_block(self): return [\"bpy.utils.register_class(\\\"MyClass\\\")\"] get_unregister_block(self) If your node has should_be_registered set to True, it needs to provide code that is added to the unregister function. The function returns a list where every string is one line. def get_unregister_block(self): return [\"bpy.utils.unregister_class(\\\"MyClass\\\")\"] required_imports(self) Your node can import modules by adding them to the required imports function. This returns a list of strings where every string is one module. def required_imports(self): return [\"bpy\",\"random\"] layout_type(self) If your node is a layout node like row, column, panel, etc. it needs to return it's layout type for the connected nodes to use. Nodes like checkbox, etc. that just live in layouts, but can't have anything living in them, don't need this function. Some nodes just need to pass the layout type of the previous node. If that's the case just call layout_type on the node connected to your nodes layout input. Be aware that this layout type is actually just the name of the variable that you still have to set in the code returned in your evaluate function. For row this would be [\"row = \",layout_type,\".row()\"] where layout_type is the layout type of the connected node. In the case of the row node it comes from layout_type = self.inputs[0].links[0].from_node.layout_type() . def layout_type(self): # example for panel return \"layout\" def layout_type(self): # example for row return \"row\" data_type(self, output) This returns the data type of the given output. It is needed for nodes like Object Data. The data type needs to be in a string and come from bpy.types . This function is called by connected data nodes that need the data type of the previous node before the addon is compiled. You can also do this from your nodes. You can see this in action with the Object Data and Get Object Data Properties nodes. def data_type(self, output): if output.name == \"Object\": return \"bpy.types.Object\" elif output.name == \"Bone\": return \"bpy.types.Bone\" reset_data_type(self, context) This is used for \"chains\" of data nodes. An example would be an Object Data node which has multiple Get Object Data Properties nodes connected after each other. Now the user changes the enum on the Object Data node. The result is that all connected nodes need to be updated because their options might change. The Object Data node starts by calling reset_data_type on the connected node. This updates its values and then calls reset_data_type on the next node. So if you create a node which makes use of these features then you need to use the reset_data_type node for that and also call that function on all nodes connected to your nodes outputs when you update something that could change the connected nodes. def reset_data_type(self, context): # do some stuff on this node if self.outputs[0].is_linked: # you should check if the right socket is connected self.outputs[0].links[0].to_node.reset_data_type(context) get_variable_line(self) This is used to create new variables in the generated addons property group. Note that there are no local variables accessible to the user. They are all stored as properties so they can be used everywhere. If you want to add a variable, you need to use this function. You will return the line that gets added to your property group like in the examples below. def get_variable_line(self): return \"prop_name: bpy.props.IntProperty(name\\\"Name\\\")\" # or def get_variable_line(self): return \"my_collection: bpy.props.CollectionProperty(type=MyPropertyGroup)\" If you want to create an array, create a collection property where the name is ArrayCollection_UID_ . UID will then be replaced with the addons unique identifier. You don't need to do that, this is managed in the compiler. This array property group has properties for any type, meaning you can use it no matter what type of array you're creating. get_array_line(self) This is used to set create defaults in your created collection properties. This is done in a function that is only called once for each file. This is meant for adding default values to arrays. def get_array_line(self): return [\"bpy.context.scene.sn_generated_addon_properties_UID_.my_name.add().bool = True\", \"bpy.context.scene.sn_generated_addon_properties_UID_.my_name.add().bool = False\"] This example adds two variables to an array called my_name . update_node(self) This function is called when the node is updated. This is the case when, for example, a socket is connected. def update_node(self): pass # do stuff to update your node Accessing Variables You can access the created variables via the generated addons collection property. This is done with bpy.context.scene.sn_generated_addon_properties_UID_ . This also makes use of the _UID_ Tag which allows you to access the generated addons unique identifier in your code. You mostly need this for variables or making sure that multiple generated addon classes don't register with the same name. One more thing Finally, we have an example node here. This doesn't have all the functions, but it has all required things and those that you usually want to use in your nodes. You can copy this to get started more quickly: #SN_MyNode import bpy from ...node_tree.base_node import SN_ScriptingBaseNode class SN_MyNode(bpy.types.Node, SN_ScriptingBaseNode): bl_idname = \"SN_MyNode\" bl_label = \"My Node\" bl_icon = \"MONKEY\" node_color = (0.2, 0.2, 0.2) should_be_registered = False docs = { \"text\": [\"<orange>This node hasn't been documented yet.</>\"], \"python\": [] } def inititialize(self,context): self.sockets.create_input(self,\"EXECUTE\",\"Execute\") self.sockets.create_output(self,\"EXECUTE\",\"Execute\") def draw_buttons(self, context, layout): pass def evaluate(self, socket, node_data, errors): return { \"blocks\": [ { \"lines\": [ ], \"indented\": [ ] } ], \"errors\": errors }","title":"Creating A Node"},{"location":"developers/create_node/#creating-a-node","text":"At the end of this page, you can find an empty example node which you can copy to quickly get started. In theory you could put multiple nodes into one file, but we don't recommend doing that to keep your files better organized.","title":"Creating A Node"},{"location":"developers/create_node/#setup","text":"You start by noting down the idnames of the nodes you want to create. This should be in the first lines of your file and written as a comment. Without this the addon will not find your node. We will use the print nodes structure as an example: #SN_PrintNode","title":"Setup"},{"location":"developers/create_node/#imports","text":"After this, there are a few imports that we require. This includes the bpy module as well as the basic visual scripting node class. The imports look as follows: import bpy from ...node_tree.base_node import SN_ScriptingBaseNode","title":"Imports"},{"location":"developers/create_node/#node-class","text":"Now you can get to your actual node class. Be aware that you could also add things like property groups or operators inbetween here, if that is something that your node requires. class SN_PrintNode(bpy.types.Node, SN_ScriptingBaseNode): # required bl_idname = \"SN_PrintNode\" bl_label = \"Print\" bl_icon = \"CONSOLE\" # optional bl_width_min = 40 bl_width_default = 160 bl_width_max = 5000 node_color = (0.2, 0.2, 0.2) should_be_registered = False min_blender_version = (2,83,0) serpens_versions = None docs = { \"text\": [\"The print node is used to <important>write things to the console</>.\", \"\", \"Value Inputs: <subtext>What is connected here will be printed.\", \"<subtext> This can be any type of data like </>numbers, strings, etc.\"], \"python\": [\"<function>print</>( <string>\\\"my example\\\"</>, <number>123</>, <string>\\\"test\\\"</> )\"] } To create your node, add a class with the name you specified at the top of your file. The class should inherit from bpy.types.Node and the base node you imported. You can treat this as a normal blender python class, meaning you can add properties and functions to it.","title":"Node Class"},{"location":"developers/create_node/#attributes","text":"bl_idname : The idname of your node. This needs to be the same as the class name and the name at the top of your file. bl_label : The label shown in the node categories and in the nodes header. bl_icon : The name of the icon that your node shows in it's header. bl_width_min : The minimum width of your node. bl_width_default : The default width of your node. bl_width_max : The maximum width of your node. node_color : This is the color of your node. Make sure to keep these pleasing for the eye and consistent between node types. should_be_registered : This is a very important argument as it determines if the node should be registered or not. We will go over this again below. serpens_versions : This is an optional parameter for providing versions of Serpens that this node is compatible with. You need to list all versions here. Changes that could affect your node are marked with changes in the first two numbers (x,x,-) . The last one is for bugfixes, etc.. The parameter is given in the format [(x,x),(x,x),...] where the x's are the first two numbers of the addon version. The default is None which allows for all versions. You can get the addon version by calling get_serpens_version in your node min_blender_version : This is the minimum required blender version for this node. If it isn't above this version it will return empty code and an error. Make sure to provide the version in the format of bpy.app.version : (x,xx,x) docs : This is the documentation for your node. It will be explained below as well. should_be_registered As mentioned before, when the node tree is compiled, the addon goes through the tree and evaluates the nodes one by one. To find the nodes to start at you use this attribute. If it is true it is a node that the addon starts from. This is the case for nodes like 'Create Operator' or 'Panel'. docs This holds the documentation for that node. It will be shown if the documentation overlay is enabled. The dictionary is split into text and python . \"text\" should explain the function of the node and what the different inputs do. Please do not just repeat the basics here, but make note of things that are specific to this node. \"python\" should hold the python equivalent of your node if possible. Both attributes need to be lists of strings, where one string represents one line. They can be left empty but both lists need to be there. You can use color formatting on your strings. This works by wrapping the text you want to color in tags. The start of a color is marked with <color_name> . The color can be one of these: [serpens, subtext, important, function, number, string, data, red, blue, green, orange, yellow, grey, lightgrey, black] or just a color in the form <(0.2, 0.3, 0.4)> . To mark the end of a colored section, use <\\> . This way you can format your python code and also mark important parts of your documentation text. These are the attributes that you need to and can set for your node. Next we will cover the functions.","title":"Attributes"},{"location":"developers/create_node/#functions","text":"You can overwrite these functions in your node to make it actually do something: initialize(self, context) This is the function that is called once when the node is created. Here you should add the inputs and outputs to your node and initialize any other values. You can add an inputs and outputs like this: def inititialize(self, context): self.sockets.create_input(self,\"EXECUTE\",\"Execute\") self.sockets.create_input(self,\"DATA\",\"Value\") self.sockets.create_output(self,\"EXECUTE\",\"Execute\") As you can see, you need to call functions from self.sockets, which handles the nodes sockets. You can find them here . evaluate(self, socket, node_data, errors) This is the most important function in your node, as it is what the addon calls to get the generated python code. This needs to return a dictionary in a specific form for this to work. def evaluate(self, socket, node_data, errors): return { \"blocks\": [ { \"lines\": [ [\"line\",\" 1\"], [\"line 2\"] ], \"indented\": [ [\"indented line\",\" 1\"], [\"indented line 2\"], { \"lines\": [ [\"code in nested code block\"] ], \"indented\": [ [\"double indented code\"] ] } ] } ], \"errors\": errors } The evaluate function needs to return a dictionary with two keys. The first is \"blocks\" which contains the actual generated python code. This is a list of code blocks. A code block is a dictionary with two keys. Those are \"lines\" and \"indented\" . Both are lists which hold lines of code. One line is a list of strings and sockets. That means that you can separate parts of the line with commas. If you have a socket in one of your lines, the node of that socket will be evaluated and the code will be added to that line. If you know that the sockets node will return multiple lines just use a list with only that socket, it will then be adjusted accordingly to add those lines. An example would be the print node where you have a line like [\"print(\", socket, \")\"] . The socket is the socket that is connected to the input of the print node. While you could check what sockets are connected yourself, we provide the node_data for evaluate. This is a dictionary containing \"input_data\" , \"output_data\" and \"node_tree\" . Node Tree is the tree, the node lives in. Input and Output data are lists. They contain one dictionary for each input/output your node has in the order they appear. Those dictionaries have the following data: socket : The socket that this dictionaries data belongs to. name : The name of the socket. value : The value of the socket. This is always a string and is the actual value entered in the socket. For a integer socket this could be '5'. connected : This is None if there is nothing connected to the socket or the connected socket. This can be used as a part of a line. code : This is the combination of value and connected. If there is no node connected to the socket it is equal to value , if there is a valid socket connected it is equal to connected . Most of the time you can use the code parameter in your lines to return the sockets value. For the print node example this would be [\"print(\", node_data[\"input_data\"][1][\"code\"], \")\"] . The \"indented\" list works the same as the \"lines\" list, but they come after the lines and are one step indented. It is important to know that you can nest code blocks. This means you can put code blocks (dictionaries with lines and indented lists) in the lists instead of a line. You can see this better in the example above. This way you can create more complicated indents and nesting in your generated code. Make sure you understand this structure before starting your nodes as it is very important for proper generated code. Finally the dictionary returned by evaluate also contains a key called \"errors\" . This is a list of errors that are related to this node. This could be a socket that is connected to something it shouldn't be or a name that hasn't been set properly. These errors will be displayed in the N-Panel. It is important that you actually make use of these and not just let the error trickle down to the actual python code. Make sure to always have default alternatives for these errors, so you can still return working code. Errors is a list of dictionaries, where each dictionary is an error. It has the following keys: title : The title of the error message. message : The content of the error message. node : The node the error came from. This is usually self . fatal : True or False, depending on if the error completely changes how the addon behaves or is just a minor issue that doesn't affect much. There is a list of errors provided as a parameter for evaluate. This contains errors coming from wrongly connected sockets. While you should use these, you can of course add your own errors if you have more specialized cases. Another parameter passed to the evaluate function is socket . This is the socket that your node got evaluated from. If you have a node that needs to return different things depending on what socket it's called from then you need to use this. If your node is being called because it's being registered this will be None. The evaluate function is where you will probably spend most of the time and where most of your code lives. Make sure to organize it properly and split some of the things in other functions to be able to properly keep track of errors. Again, it's important that the user doesn't have to deal with actual python errors. This addon is not about generating the most efficient code, but to provide the best user experience when making addons with no coding knowledge. draw_buttons(self, context, layout) Here you can draw additional layouts on your node. This will be shown at the top of your nodes and can include anything you can put in a blender ui layout. def draw_buttons(self, context, layout): layout.label(text=\"My label\") layout.prop(self,\"my_node_property\") You can also draw an icon selector here by calling self.draw_icon_chooser(layout) . The chosen icon name can then be accessed with self.icon anywhere in your node. get_register_block(self) If your node has should_be_registered set to True, it needs to provide code that is added to the register function. The function returns a list where every string is one line. def get_register_block(self): return [\"bpy.utils.register_class(\\\"MyClass\\\")\"] get_unregister_block(self) If your node has should_be_registered set to True, it needs to provide code that is added to the unregister function. The function returns a list where every string is one line. def get_unregister_block(self): return [\"bpy.utils.unregister_class(\\\"MyClass\\\")\"] required_imports(self) Your node can import modules by adding them to the required imports function. This returns a list of strings where every string is one module. def required_imports(self): return [\"bpy\",\"random\"] layout_type(self) If your node is a layout node like row, column, panel, etc. it needs to return it's layout type for the connected nodes to use. Nodes like checkbox, etc. that just live in layouts, but can't have anything living in them, don't need this function. Some nodes just need to pass the layout type of the previous node. If that's the case just call layout_type on the node connected to your nodes layout input. Be aware that this layout type is actually just the name of the variable that you still have to set in the code returned in your evaluate function. For row this would be [\"row = \",layout_type,\".row()\"] where layout_type is the layout type of the connected node. In the case of the row node it comes from layout_type = self.inputs[0].links[0].from_node.layout_type() . def layout_type(self): # example for panel return \"layout\" def layout_type(self): # example for row return \"row\" data_type(self, output) This returns the data type of the given output. It is needed for nodes like Object Data. The data type needs to be in a string and come from bpy.types . This function is called by connected data nodes that need the data type of the previous node before the addon is compiled. You can also do this from your nodes. You can see this in action with the Object Data and Get Object Data Properties nodes. def data_type(self, output): if output.name == \"Object\": return \"bpy.types.Object\" elif output.name == \"Bone\": return \"bpy.types.Bone\" reset_data_type(self, context) This is used for \"chains\" of data nodes. An example would be an Object Data node which has multiple Get Object Data Properties nodes connected after each other. Now the user changes the enum on the Object Data node. The result is that all connected nodes need to be updated because their options might change. The Object Data node starts by calling reset_data_type on the connected node. This updates its values and then calls reset_data_type on the next node. So if you create a node which makes use of these features then you need to use the reset_data_type node for that and also call that function on all nodes connected to your nodes outputs when you update something that could change the connected nodes. def reset_data_type(self, context): # do some stuff on this node if self.outputs[0].is_linked: # you should check if the right socket is connected self.outputs[0].links[0].to_node.reset_data_type(context) get_variable_line(self) This is used to create new variables in the generated addons property group. Note that there are no local variables accessible to the user. They are all stored as properties so they can be used everywhere. If you want to add a variable, you need to use this function. You will return the line that gets added to your property group like in the examples below. def get_variable_line(self): return \"prop_name: bpy.props.IntProperty(name\\\"Name\\\")\" # or def get_variable_line(self): return \"my_collection: bpy.props.CollectionProperty(type=MyPropertyGroup)\" If you want to create an array, create a collection property where the name is ArrayCollection_UID_ . UID will then be replaced with the addons unique identifier. You don't need to do that, this is managed in the compiler. This array property group has properties for any type, meaning you can use it no matter what type of array you're creating. get_array_line(self) This is used to set create defaults in your created collection properties. This is done in a function that is only called once for each file. This is meant for adding default values to arrays. def get_array_line(self): return [\"bpy.context.scene.sn_generated_addon_properties_UID_.my_name.add().bool = True\", \"bpy.context.scene.sn_generated_addon_properties_UID_.my_name.add().bool = False\"] This example adds two variables to an array called my_name . update_node(self) This function is called when the node is updated. This is the case when, for example, a socket is connected. def update_node(self): pass # do stuff to update your node","title":"Functions"},{"location":"developers/create_node/#accessing-variables","text":"You can access the created variables via the generated addons collection property. This is done with bpy.context.scene.sn_generated_addon_properties_UID_ . This also makes use of the _UID_ Tag which allows you to access the generated addons unique identifier in your code. You mostly need this for variables or making sure that multiple generated addon classes don't register with the same name.","title":"Accessing Variables"},{"location":"developers/create_node/#one-more-thing","text":"Finally, we have an example node here. This doesn't have all the functions, but it has all required things and those that you usually want to use in your nodes. You can copy this to get started more quickly: #SN_MyNode import bpy from ...node_tree.base_node import SN_ScriptingBaseNode class SN_MyNode(bpy.types.Node, SN_ScriptingBaseNode): bl_idname = \"SN_MyNode\" bl_label = \"My Node\" bl_icon = \"MONKEY\" node_color = (0.2, 0.2, 0.2) should_be_registered = False docs = { \"text\": [\"<orange>This node hasn't been documented yet.</>\"], \"python\": [] } def inititialize(self,context): self.sockets.create_input(self,\"EXECUTE\",\"Execute\") self.sockets.create_output(self,\"EXECUTE\",\"Execute\") def draw_buttons(self, context, layout): pass def evaluate(self, socket, node_data, errors): return { \"blocks\": [ { \"lines\": [ ], \"indented\": [ ] } ], \"errors\": errors }","title":"One more thing"},{"location":"developers/distribution/","text":"Distribution To distribute your package, create a zip file. The name of this file doesn't affect the package itself. Package Info To distribute your package to others, you'll need to create a package_info.json file. The file should look like this: { \"name\": \"Name Of Your Package\", \"description\": \"This is the packages description\", \"author\": \"Your Name\", \"nodes\": [ ] } name: This is the name of your package which will be shown in the user preferences. description: This is the description of your package which will be shown in the user preferences. autor: You can put your name here to be shown in the user preferences. nodes: This is a list of all nodes that are contained in your package. This is explained below. The package_info.json file goes in the root of your zip file. The node category folders with the nodes python files should also go in the zip file. The folder structure should look like this: . \u251c\u2500\u2500 package_info.json \u251c\u2500\u2500 Interface \u2502 \u2514\u2500\u2500 new_node.py \u251c\u2500\u2500 New Category \u2502 \u251c\u2500\u2500 my_node.py \u2502 \u2514\u2500\u2500 my_other_node.py The nodes parameter in the package_json should be a list of strings. Those strings should be relative filepaths to the different nodes. The example above would look like this: [\"Interface/new_node.py\", \"New Category/my_node.py\", \"New Category/my_other_node.py\"] As mentioned before, you do not need to add the __init__.py files to these category folders. Wrapping Up Once you finished packing up your zip file you are ready to distribute it to other people! Once again, make sure to let us know if you create a package so we can promote it and add it to the marketplace for other people to find. This is purely benefitial for you, no matter if you sell the package or give it away for free. If you have any other question, please let us know on discord or on twitter .","title":"Distribution"},{"location":"developers/distribution/#distribution","text":"To distribute your package, create a zip file. The name of this file doesn't affect the package itself.","title":"Distribution"},{"location":"developers/distribution/#package-info","text":"To distribute your package to others, you'll need to create a package_info.json file. The file should look like this: { \"name\": \"Name Of Your Package\", \"description\": \"This is the packages description\", \"author\": \"Your Name\", \"nodes\": [ ] } name: This is the name of your package which will be shown in the user preferences. description: This is the description of your package which will be shown in the user preferences. autor: You can put your name here to be shown in the user preferences. nodes: This is a list of all nodes that are contained in your package. This is explained below. The package_info.json file goes in the root of your zip file. The node category folders with the nodes python files should also go in the zip file. The folder structure should look like this: . \u251c\u2500\u2500 package_info.json \u251c\u2500\u2500 Interface \u2502 \u2514\u2500\u2500 new_node.py \u251c\u2500\u2500 New Category \u2502 \u251c\u2500\u2500 my_node.py \u2502 \u2514\u2500\u2500 my_other_node.py The nodes parameter in the package_json should be a list of strings. Those strings should be relative filepaths to the different nodes. The example above would look like this: [\"Interface/new_node.py\", \"New Category/my_node.py\", \"New Category/my_other_node.py\"] As mentioned before, you do not need to add the __init__.py files to these category folders.","title":"Package Info"},{"location":"developers/distribution/#wrapping-up","text":"Once you finished packing up your zip file you are ready to distribute it to other people! Once again, make sure to let us know if you create a package so we can promote it and add it to the marketplace for other people to find. This is purely benefitial for you, no matter if you sell the package or give it away for free. If you have any other question, please let us know on discord or on twitter .","title":"Wrapping Up"},{"location":"developers/getting_started/","text":"Introduction The addon allows you to create packages of nodes that can be installed by the user. You are free to develop these packages and share or sell them. If you develop a package, please let us know so we can promote it. There is also a built in marketplace which we can update over the air. This allows users to look for packages directly in the addon and not have to scout the internet to find them. Please reach out to us via discord when you have a package for us to share. What you will do Your package contains custom nodes which can then be used to generate addons. The basic idea of a node tree is, that when the node tree is compiled, the first node gets evaluated and returns a dictionary with the generated code. This code can then contain sockets of other nodes which, again, will get evaluated and return code themselves. This process is repeated until there is only code left. More info A node can look however you want. You can write custom operators that allow you to select UI elements or have lists, enums, checkboxes, ... You can put anything on a node that you want, you just need to make sure a correctly structured dictionary is returned. You also should not add custom socket types. The addon is doing things like generating sockets dynamically, checking for errors and things like that which require specific treatment for each socket type. If you feel like a socket type is missing, please let us know. You should make sure that your nodes have icons that make sense, have visually pleasing colors and follow a consistent naming scheme. You might want to consider to add a prefix in front of your nodes names to show that they belong together. Development The basic structure which you will develop is the following: You will distribute a .zip file to others which can then be installed in the addons user preferences. Your zip file can hold multiple folders. These folders are where the .py files for the nodes go. Each python file equals to one node. The folders correspond to the node categories. These are the lists that show up in the Node Add menu. Example: If you want to create a node in the Interface category, you'd add a folder called Interface and a python file inside that folder. This is where the code for your node goes. If you create a folder with a name that doesn't exist yet, that category will be created. You can not nest folders to create subcategories! Finally you will need a package_info.json file which also goes in the zip file. This holds information on your package. This will be explained in more detail as well. An example for the structure of your package zip file could look as follows: . \u251c\u2500\u2500 package_info.json \u251c\u2500\u2500 Interface \u2502 \u2514\u2500\u2500 new_node.py \u251c\u2500\u2500 New Category \u2502 \u251c\u2500\u2500 my_node.py \u2502 \u2514\u2500\u2500 my_other_node.py Get Started To actually get started developing we have a few recommendations. To work on a node you want to add to your package, you need to temporarily add it to the addon itself. Start by finding the folder where you have installed the visual scripting addon. You can find this in the user preferences in the addons panel under File . In this folder you'll find a folder called nodes. This is the folder you'll work in. When you open up the folder you will find the directories corresponding to the node categories, as mentioned in the introduction. These are the installed categories and nodes. When a user installs your package, the zip files content will go in here. You don't need to and can't touch any of the other files in any of the addons folders. You only create your nodes in the corresponding folder for development and then put them in the zip file for distribution. To create a new category during development, you create a subfolder in nodes with the corresponding name. Now you need to add a file called __init__.py in that folder. This is for blender to recognize it as a part of the addon, but can be left empty. Note that you do not need to add this file in your final zip. This will be done automatically if necessary. Your new category should then look something like this. If you just want to add a node in an existing category you only need to add your .py file for the node itself in the existing folder. You can have new categories and existing ones in one package. Note that empty categories will not be shown, meaning you need to create a node first for it to show up. Conclusion You should now know how to set up your editor for developing your package. Start by creating a file for a node in a new or existing category. We will now continue with developing a node. Later we will get into how to distribute your package in the mentioned zip file once you are done with development.","title":"Getting Started"},{"location":"developers/getting_started/#introduction","text":"The addon allows you to create packages of nodes that can be installed by the user. You are free to develop these packages and share or sell them. If you develop a package, please let us know so we can promote it. There is also a built in marketplace which we can update over the air. This allows users to look for packages directly in the addon and not have to scout the internet to find them. Please reach out to us via discord when you have a package for us to share.","title":"Introduction"},{"location":"developers/getting_started/#what-you-will-do","text":"Your package contains custom nodes which can then be used to generate addons. The basic idea of a node tree is, that when the node tree is compiled, the first node gets evaluated and returns a dictionary with the generated code. This code can then contain sockets of other nodes which, again, will get evaluated and return code themselves. This process is repeated until there is only code left.","title":"What you will do"},{"location":"developers/getting_started/#more-info","text":"A node can look however you want. You can write custom operators that allow you to select UI elements or have lists, enums, checkboxes, ... You can put anything on a node that you want, you just need to make sure a correctly structured dictionary is returned. You also should not add custom socket types. The addon is doing things like generating sockets dynamically, checking for errors and things like that which require specific treatment for each socket type. If you feel like a socket type is missing, please let us know. You should make sure that your nodes have icons that make sense, have visually pleasing colors and follow a consistent naming scheme. You might want to consider to add a prefix in front of your nodes names to show that they belong together.","title":"More info"},{"location":"developers/getting_started/#development","text":"The basic structure which you will develop is the following: You will distribute a .zip file to others which can then be installed in the addons user preferences. Your zip file can hold multiple folders. These folders are where the .py files for the nodes go. Each python file equals to one node. The folders correspond to the node categories. These are the lists that show up in the Node Add menu. Example: If you want to create a node in the Interface category, you'd add a folder called Interface and a python file inside that folder. This is where the code for your node goes. If you create a folder with a name that doesn't exist yet, that category will be created. You can not nest folders to create subcategories! Finally you will need a package_info.json file which also goes in the zip file. This holds information on your package. This will be explained in more detail as well. An example for the structure of your package zip file could look as follows: . \u251c\u2500\u2500 package_info.json \u251c\u2500\u2500 Interface \u2502 \u2514\u2500\u2500 new_node.py \u251c\u2500\u2500 New Category \u2502 \u251c\u2500\u2500 my_node.py \u2502 \u2514\u2500\u2500 my_other_node.py","title":"Development"},{"location":"developers/getting_started/#get-started","text":"To actually get started developing we have a few recommendations. To work on a node you want to add to your package, you need to temporarily add it to the addon itself. Start by finding the folder where you have installed the visual scripting addon. You can find this in the user preferences in the addons panel under File . In this folder you'll find a folder called nodes. This is the folder you'll work in. When you open up the folder you will find the directories corresponding to the node categories, as mentioned in the introduction. These are the installed categories and nodes. When a user installs your package, the zip files content will go in here. You don't need to and can't touch any of the other files in any of the addons folders. You only create your nodes in the corresponding folder for development and then put them in the zip file for distribution. To create a new category during development, you create a subfolder in nodes with the corresponding name. Now you need to add a file called __init__.py in that folder. This is for blender to recognize it as a part of the addon, but can be left empty. Note that you do not need to add this file in your final zip. This will be done automatically if necessary. Your new category should then look something like this. If you just want to add a node in an existing category you only need to add your .py file for the node itself in the existing folder. You can have new categories and existing ones in one package. Note that empty categories will not be shown, meaning you need to create a node first for it to show up.","title":"Get Started"},{"location":"developers/getting_started/#conclusion","text":"You should now know how to set up your editor for developing your package. Start by creating a file for a node in a new or existing category. We will now continue with developing a node. Later we will get into how to distribute your package in the mentioned zip file once you are done with development.","title":"Conclusion"},{"location":"developers/socket_handler/","text":"Socket Handler The socket handler holds a few functions that can help you to manage your nodes sockets. You can access it anywhere in your node with self.sockets . Socket Types There are different socket types that you can create. The names listed below are the socket types identifiers which we will use later: STRING : A string socket with a text field on the node. If this needs to be a valid python name then you can set your_socket.is_python_name to True and the addon will update the text to be valid python. BOOLEAN : A boolean socket with a toggle button on the node. You can set this to a checkbox by setting your_socket.show_toggle to False. You can also show the value as a text by setting your_socket.display_boolean_text to True. INTEGER : An integer socket. You can set your_socket.only_positive to True, to only allow for postive values. FLOAT : A float socket. You can set your_socket.use_factor to True, to have a factor slider from 0.0 to 1.0. VECTOR : A vector socket. You can set your_socket.is_color to True, to have a color displayed on your node. You can also set your_socket.use_four_numbers to True, to get a vector with four numbers. DATA : A data socket, which can have any of the previously mentioned sockets connected. EXECUTE : An execute socket, which is used to define the program flow. LAYOUT : A layout socket, which is used to define the flow of a layout. OBJECT : A socket for passing a singular data block between nodes. This is differentiated from a collection socket with the round input. COLLECTION : A socket for passing a collection of data blocks between nodes. This is differentiated from a single data block socket with the square input. SEPARATOR : A socket for separating your sockets. This is purely visual and does not have any use otherwise. create_input(node, socket_type, label, dynamic=False) This will create an input. You need to give it the node to create it on, which is usually self . It also requires the socket type which is one of the names above, as well as the label, which is the name displayed on the node. The dynamic parameter is optional. If it's set to True, it will dynamically add more sockets with the same appearance as you connect nodes to it. self.sockets.create_input(self, \"STRING\", \"My Socket\") self.sockets.create_input(self, \"FLOAT\", \"My Dynamic Socket\", True) This function also returns the created socket, so you can set the properties explained above. create_output(node, socket_type, label, dynamic=False) See create_input . self.sockets.create_output(self, \"STRING\", \"My Socket\") self.sockets.create_output(self, \"FLOAT\", \"My Dynamic Socket\", True) This function also returns the created socket, so you can set the properties explained above. remove_input(node, input_socket) This will remove the given socket from the node. The node parameter is usually set to self . self.sockets.remove_input(self, self.inputs[0]) remove_output(node, output_socket) See remove_input . self.sockets.remove_output(self, self.outputs[0]) change_socket_type(node, socket, socket_type, label=\"\") This will turn the given socket into the given socket type. If you give a label then that label will be used instead of the old sockets label. The node parameter is usually set to self . self.sockets.change_socket_type(self, self.inputs[0], \"STRING\", label=\"I'm now a string!\")","title":"Socket Handler"},{"location":"developers/socket_handler/#socket-handler","text":"The socket handler holds a few functions that can help you to manage your nodes sockets. You can access it anywhere in your node with self.sockets .","title":"Socket Handler"},{"location":"developers/socket_handler/#socket-types","text":"There are different socket types that you can create. The names listed below are the socket types identifiers which we will use later: STRING : A string socket with a text field on the node. If this needs to be a valid python name then you can set your_socket.is_python_name to True and the addon will update the text to be valid python. BOOLEAN : A boolean socket with a toggle button on the node. You can set this to a checkbox by setting your_socket.show_toggle to False. You can also show the value as a text by setting your_socket.display_boolean_text to True. INTEGER : An integer socket. You can set your_socket.only_positive to True, to only allow for postive values. FLOAT : A float socket. You can set your_socket.use_factor to True, to have a factor slider from 0.0 to 1.0. VECTOR : A vector socket. You can set your_socket.is_color to True, to have a color displayed on your node. You can also set your_socket.use_four_numbers to True, to get a vector with four numbers. DATA : A data socket, which can have any of the previously mentioned sockets connected. EXECUTE : An execute socket, which is used to define the program flow. LAYOUT : A layout socket, which is used to define the flow of a layout. OBJECT : A socket for passing a singular data block between nodes. This is differentiated from a collection socket with the round input. COLLECTION : A socket for passing a collection of data blocks between nodes. This is differentiated from a single data block socket with the square input. SEPARATOR : A socket for separating your sockets. This is purely visual and does not have any use otherwise. create_input(node, socket_type, label, dynamic=False) This will create an input. You need to give it the node to create it on, which is usually self . It also requires the socket type which is one of the names above, as well as the label, which is the name displayed on the node. The dynamic parameter is optional. If it's set to True, it will dynamically add more sockets with the same appearance as you connect nodes to it. self.sockets.create_input(self, \"STRING\", \"My Socket\") self.sockets.create_input(self, \"FLOAT\", \"My Dynamic Socket\", True) This function also returns the created socket, so you can set the properties explained above. create_output(node, socket_type, label, dynamic=False) See create_input . self.sockets.create_output(self, \"STRING\", \"My Socket\") self.sockets.create_output(self, \"FLOAT\", \"My Dynamic Socket\", True) This function also returns the created socket, so you can set the properties explained above. remove_input(node, input_socket) This will remove the given socket from the node. The node parameter is usually set to self . self.sockets.remove_input(self, self.inputs[0]) remove_output(node, output_socket) See remove_input . self.sockets.remove_output(self, self.outputs[0]) change_socket_type(node, socket, socket_type, label=\"\") This will turn the given socket into the given socket type. If you give a label then that label will be used instead of the old sockets label. The node parameter is usually set to self . self.sockets.change_socket_type(self, self.inputs[0], \"STRING\", label=\"I'm now a string!\")","title":"Socket Types"}]}