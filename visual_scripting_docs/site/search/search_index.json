{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This will hold the documentation for the visual scripting addon","title":"Introduction"},{"location":"#introduction","text":"This will hold the documentation for the visual scripting addon","title":"Introduction"},{"location":"developers/","text":"Introduction The addon allows you to create packages of nodes that can be installed by the user. You are free to develop these packages and share or sell them. If you develop a package, please let us know so we can promote it. This documentation will teach you how we suggest you develop a node package and what we require. What you can do Your package contains custom nodes which can then be used to create addons. The basic idea is that each node returns a dictionary with the code structure. This will then be compiled by the visual scripting addon to create the final python code. This will be explained in more detail in this documentation. Development The basic structure which you will develop is the following: You will distribute a .zip file to others which can then be installed in the addons user preferences. Your zip file can hold multiple folders. These folders are where the .py files for the nodes go. Each python file equals to one node. The folders correspond to the node categories. These are the lists that show up in the Node Add menu. Example: If you want to create a node in the Interface category, you'd add a folder called Interface and a python file inside that folder. This will be where the code for your node goes. You can't nest folders to create subcategories! If you create a folder with a name that doesn't exist yet, that category will be created. Finally you will need a package_info.json file which also goes in the zip file. This holds information on your package. This will be explained in more detail as well.","title":"Introduction"},{"location":"developers/#introduction","text":"The addon allows you to create packages of nodes that can be installed by the user. You are free to develop these packages and share or sell them. If you develop a package, please let us know so we can promote it. This documentation will teach you how we suggest you develop a node package and what we require.","title":"Introduction"},{"location":"developers/#what-you-can-do","text":"Your package contains custom nodes which can then be used to create addons. The basic idea is that each node returns a dictionary with the code structure. This will then be compiled by the visual scripting addon to create the final python code. This will be explained in more detail in this documentation.","title":"What you can do"},{"location":"developers/#development","text":"The basic structure which you will develop is the following: You will distribute a .zip file to others which can then be installed in the addons user preferences. Your zip file can hold multiple folders. These folders are where the .py files for the nodes go. Each python file equals to one node. The folders correspond to the node categories. These are the lists that show up in the Node Add menu. Example: If you want to create a node in the Interface category, you'd add a folder called Interface and a python file inside that folder. This will be where the code for your node goes. You can't nest folders to create subcategories! If you create a folder with a name that doesn't exist yet, that category will be created. Finally you will need a package_info.json file which also goes in the zip file. This holds information on your package. This will be explained in more detail as well.","title":"Development"},{"location":"developers/categories/","text":"Setting up a node category Naming: To add a new node category, create a new folder in the nodes directory. The name of this folder will be used as the name of the category. Here the underscores will be replaced with spaces and the first letters of words will be made uppercase. However you can just use spaces in the name as well. If you create a folder called my_awesome_node_category , the node category will be called My Awesome Node Category . Init file: To get the addon to recognize your category, you need to add a file called __init__.py inside the folder. This file can be empty but it needs to be there. However it's important to know that this is not required to be included in the final package, even if you create new categories. It's just needed during development. Notes: It's important to know that empty categories will not be shown. This means that after you have created your category, you need to add a node to it first for it to be shown in the add node panel.","title":"Creating Categories"},{"location":"developers/categories/#setting-up-a-node-category","text":"Naming: To add a new node category, create a new folder in the nodes directory. The name of this folder will be used as the name of the category. Here the underscores will be replaced with spaces and the first letters of words will be made uppercase. However you can just use spaces in the name as well. If you create a folder called my_awesome_node_category , the node category will be called My Awesome Node Category . Init file: To get the addon to recognize your category, you need to add a file called __init__.py inside the folder. This file can be empty but it needs to be there. However it's important to know that this is not required to be included in the final package, even if you create new categories. It's just needed during development. Notes: It's important to know that empty categories will not be shown. This means that after you have created your category, you need to add a node to it first for it to be shown in the add node panel.","title":"Setting up a node category"},{"location":"developers/distributing/","text":"Distributing To distribute your package, create a zip file. The name of this file doesn't matter. Package Info To distribute your package to others, you'll need to create a package_info.json file. The file should look like this: { \"name\": \"Name Of Your Package\", \"description\": \"This is the packages description\", \"author\": \"Your Name\", \"nodes\": [ ] } name: This is the name of your package which will be shown in the user preferences description: This is the description of your package which will be shown in the user preferences autor: You can put your name here to be shown in the user preferences nodes: This is a list of all nodes that are contained in your package. This is explained below The package_info.json file goes right in the root of your zip file. The node category folders with the node python files should also go in the zip file. The folder structure should look like this: .zip file |package_info.json |category one |____node_one.py |____node_two.py |category two |____node_three.py The nodes parameter in the package_json should be a list of strings. Those strings should be relative filepaths to the different nodes. An example could look like this: [\"category one/node_one.py\", \"category one/node_two.py\", \"category two/node_three.py\"] Once you finished packing up your zip file you are ready to distribute it to other people! Once again, make sure to let us know if you create a package so we can promote it.","title":"Distributing"},{"location":"developers/distributing/#distributing","text":"To distribute your package, create a zip file. The name of this file doesn't matter.","title":"Distributing"},{"location":"developers/distributing/#package-info","text":"To distribute your package to others, you'll need to create a package_info.json file. The file should look like this: { \"name\": \"Name Of Your Package\", \"description\": \"This is the packages description\", \"author\": \"Your Name\", \"nodes\": [ ] } name: This is the name of your package which will be shown in the user preferences description: This is the description of your package which will be shown in the user preferences autor: You can put your name here to be shown in the user preferences nodes: This is a list of all nodes that are contained in your package. This is explained below The package_info.json file goes right in the root of your zip file. The node category folders with the node python files should also go in the zip file. The folder structure should look like this: .zip file |package_info.json |category one |____node_one.py |____node_two.py |category two |____node_three.py The nodes parameter in the package_json should be a list of strings. Those strings should be relative filepaths to the different nodes. An example could look like this: [\"category one/node_one.py\", \"category one/node_two.py\", \"category two/node_three.py\"] Once you finished packing up your zip file you are ready to distribute it to other people! Once again, make sure to let us know if you create a package so we can promote it.","title":"Package Info"},{"location":"developers/nodes/","text":"The concept The basic idea is that some of the nodes in the node tree are marked to be registered. Those are things like Start Operator or Create Panel. They mark the start of a block of code. Now the compiler will call the evaluate function on the node. This will return the python code of the node. This is not just text, but can also consist of other nodes that are connected to the start node. From here on the compiler will call evaluate on all the parts of the code that are nodes until all the code is text. This is the final python code and will get added to the addon. You will mainly write the evaluate function to give back the code that is returned. We provide a few helpful things to make that easier. The information below should be useful to get started, but if you want to create a specific node, try to look at other nodes that do similar things to figure out how to get the things you want to achieve. Setting up a node Python file: To create a node, add your python file in the category directory you want it to go in. The name of the file doesn't matter. Imports: To create a scripting node, you'll need to import a few things. You can just copy the code below to get started: import bpy from ..base.base_node import SN_ScriptingBaseNode from ...compile.compiler import compiler from ..base.node_looks import node_colors, node_icons bpy: This is obviously needed to create a custom node in blender SN_ScriptingBaseNode: This is the basic Scripting Node which your created node will inherit from compiler: This function returns the compiler object. You will only need the socket_update function from this. You need to call this in any properties you create node_colors: This is a dictionary with the colors that are used by nodes. An example of this can be seen below in the init function. Here you can set the color of the node. The possible options are [\"INTERFACE\", \"LOGIC\", \"INPUT\", \"OPERATOR\", \"PROGRAM\", \"SCENE\"] node_icons: This is a dictionary with the icon names for the nodes. An example of this can be seen below under bl_icon. The possible options are [\"INTERFACE\", \"LOGIC\", \"INPUT\", \"OPERATOR\", \"PROGRAM\", \"SCENE\"] The node: Here's the basic code for creating a node: class SN_NodeName(bpy.types.Node, SN_ScriptingBaseNode): bl_idname = \"SN_NodeName\" bl_label = \"The Nodes Label\" bl_icon = node_icons[\"PROGRAM\"] _should_be_registered = False _dynamic_layout_sockets = False _debug_node = False @classmethod def poll(cls, ntree): return ntree.bl_idname == 'ScriptingNodesTree' def socket_update(self, context): compiler().socket_update(context) def init(self, context): self.use_custom_color = True #self.color = node_colors[\"PROGRAM\"] def draw_buttons(self, context, layout): pass def copy(self, node): pass def free(self): pass def evaluate(self, output): return { \"blocks\": [], \"errors\": [] } def layout_type(self): return \"\" def data_type(self, output): return None def needed_imports(self): return [] def get_register_block(self): return [] def get_unregister_block(self): return [] should_be_registered : This property defines if the node should be registered. This should be true if the result of the node should add something to the register and unregister functions. Examples of this are the Create Operator and Create Panel nodes _dynamic_layout_sockets: If this is true, layout sockets will be added to this node automatically. When a node is connected another one will be added, when one is disconnected it will be removed _debug_node: If this is true, the output of the evaluate function will be printed in the console when it is compiled. This is useful for debugging socket_update: You can use this as the update function of properties you create on the node. This is necessary to make the node work with the auto reload option init: This function gets called when the node is created. Here you can create the node in- and outputs. This is a blender function and the in and outputs can be created as usual. The types of sockets are [\"SN_StringSocket\", \"SN_FloatSocket\", \"SN_IntSocket\", \"SN_BooleanSocket\", \"SN_DataSocket\", \"SN_VectorSocket\", \"SN_EnumSocket\", \"SN_LayoutSocket\", \"SN_ProgramSocket\", \"SN_SceneDataSocket\"] draw_buttons: Here you can draw additional options on the node. This is a blender function and can be used as usual copy: This function gets called when the node is copied. This is a blender function and can be used as usual free: This function gets called when the node is deleted. This is a blender function and can be used as usual evaluate: This is the function that the compiler will call to get the python code from the node. The function gets an output. You can use this if youre node has multiple outputs. This doesn't apply to most nodes but if you make something like a data node where every output returns a single line then you might need to use this. The function returns a dictionary. This will be explained below. layout_type: This is needed if you create a layout node. An example is the Row node which returns \"row\". This can be used by connected nodes to find the layout type it should use. A Label node might call it on the connected node to return row.label data_type This is only needed if you create a node that uses data properties. An example is the scene data properties node which returns \"bpy.types.\" combined with the type of the selected property, which can be found using .fixed_type. It should also return \"bpy.types.\" + the data type + \".bl_rna.properties['\" + the selected property + \"']\" if the selected property is a collection. This can be used by connected nodes to get the properties of the connected data type using .bl_rna.properties and .fixed_type. needed_imports: This contains a list of strings of the things that this node needs to import. The most common example is [\"bpy\"] get_register_block: This is only needed if _should_be_registered is true. It returns a list of strings, where every string is one line in the register function of the addon. get_unregister_block: This is only needed if _should_be_registered is true. It returns a list of strings, where every string is one line in the unregister function of the addon. Evaluate function: The evaluate function returns a dictionary containing a list called \"blocks\" and a list called \"errors\". Blocks: This is the code that the node creates. The blocks list contains dictionaries. These dictionaries have the following parameters: lines: This is a list of code lines. Each line is either a list or a node socket. If it is a node socket, the compiler will call evaluate on the sockets node to generate the corresponding lines of code. This means that a socket without a list equates to multiple new lines of code. The other option is to have a list of strings and sockets. The sockets in these lists should belong to nodes which only return single lines. An example for this would be a print node where you have something like [\"print(\", connected_socket, \")\"]. indented: This is also a list of lists and sockets and works the same way as the lines list. The different is that these lines will come after the lines list and will be indented. This can be used if you need to indent code in your node. You can nest these code blocks, meaning that you can put dictionaries with lines and indented code inside other lists of lines or indents. With this you should be able to create any code you could need. Errors: This is a list of dictionaries that have the following parameters. It contains the errors that the node has. This could be that the user has connected a wrong input or something similar: error: This is the type of error. It's a string from the following list: [\"test_error\", \"wrong_socket_inp\", \"no_connection_inp\", \"wrong_socket_out\", \"no_connection_out\", \"no_connection\", \"no_layout_connection\", \"no_name_func\", \"no_name_var\", \"no_var_available\", \"no_prop_selected\", \"wrong_prop\"] node: This is the node that caused the error. Usually this is self Helpful tools: We provide a few tools that should help you with the evaluating of nodes. You don't have to use these but they should make your life easier. SocketHandler: You can access the socket handler with self.SocketHandler. It helps you with getting the value of inputs that could be connected to other nodes. The most important function here is socket_value which takes the input socket. It also can take an optional parameter for if the result should be returned as a list which is only useful for layout and program sockets. The function returns the value of the socket or the connected socket. It also checks for errors and returns those as well. The second useful function is get_layout_values which returns all layout values as well as the errors for the given node ErrorHandler: The function you will use here is handle_text. It checks for keywords in the text to see if they don't work with python syntax. This could be useful when creating something like a function which can't have any type of name","title":"Creating Nodes"},{"location":"developers/nodes/#the-concept","text":"The basic idea is that some of the nodes in the node tree are marked to be registered. Those are things like Start Operator or Create Panel. They mark the start of a block of code. Now the compiler will call the evaluate function on the node. This will return the python code of the node. This is not just text, but can also consist of other nodes that are connected to the start node. From here on the compiler will call evaluate on all the parts of the code that are nodes until all the code is text. This is the final python code and will get added to the addon. You will mainly write the evaluate function to give back the code that is returned. We provide a few helpful things to make that easier. The information below should be useful to get started, but if you want to create a specific node, try to look at other nodes that do similar things to figure out how to get the things you want to achieve.","title":"The concept"},{"location":"developers/nodes/#setting-up-a-node","text":"Python file: To create a node, add your python file in the category directory you want it to go in. The name of the file doesn't matter. Imports: To create a scripting node, you'll need to import a few things. You can just copy the code below to get started: import bpy from ..base.base_node import SN_ScriptingBaseNode from ...compile.compiler import compiler from ..base.node_looks import node_colors, node_icons bpy: This is obviously needed to create a custom node in blender SN_ScriptingBaseNode: This is the basic Scripting Node which your created node will inherit from compiler: This function returns the compiler object. You will only need the socket_update function from this. You need to call this in any properties you create node_colors: This is a dictionary with the colors that are used by nodes. An example of this can be seen below in the init function. Here you can set the color of the node. The possible options are [\"INTERFACE\", \"LOGIC\", \"INPUT\", \"OPERATOR\", \"PROGRAM\", \"SCENE\"] node_icons: This is a dictionary with the icon names for the nodes. An example of this can be seen below under bl_icon. The possible options are [\"INTERFACE\", \"LOGIC\", \"INPUT\", \"OPERATOR\", \"PROGRAM\", \"SCENE\"] The node: Here's the basic code for creating a node: class SN_NodeName(bpy.types.Node, SN_ScriptingBaseNode): bl_idname = \"SN_NodeName\" bl_label = \"The Nodes Label\" bl_icon = node_icons[\"PROGRAM\"] _should_be_registered = False _dynamic_layout_sockets = False _debug_node = False @classmethod def poll(cls, ntree): return ntree.bl_idname == 'ScriptingNodesTree' def socket_update(self, context): compiler().socket_update(context) def init(self, context): self.use_custom_color = True #self.color = node_colors[\"PROGRAM\"] def draw_buttons(self, context, layout): pass def copy(self, node): pass def free(self): pass def evaluate(self, output): return { \"blocks\": [], \"errors\": [] } def layout_type(self): return \"\" def data_type(self, output): return None def needed_imports(self): return [] def get_register_block(self): return [] def get_unregister_block(self): return [] should_be_registered : This property defines if the node should be registered. This should be true if the result of the node should add something to the register and unregister functions. Examples of this are the Create Operator and Create Panel nodes _dynamic_layout_sockets: If this is true, layout sockets will be added to this node automatically. When a node is connected another one will be added, when one is disconnected it will be removed _debug_node: If this is true, the output of the evaluate function will be printed in the console when it is compiled. This is useful for debugging socket_update: You can use this as the update function of properties you create on the node. This is necessary to make the node work with the auto reload option init: This function gets called when the node is created. Here you can create the node in- and outputs. This is a blender function and the in and outputs can be created as usual. The types of sockets are [\"SN_StringSocket\", \"SN_FloatSocket\", \"SN_IntSocket\", \"SN_BooleanSocket\", \"SN_DataSocket\", \"SN_VectorSocket\", \"SN_EnumSocket\", \"SN_LayoutSocket\", \"SN_ProgramSocket\", \"SN_SceneDataSocket\"] draw_buttons: Here you can draw additional options on the node. This is a blender function and can be used as usual copy: This function gets called when the node is copied. This is a blender function and can be used as usual free: This function gets called when the node is deleted. This is a blender function and can be used as usual evaluate: This is the function that the compiler will call to get the python code from the node. The function gets an output. You can use this if youre node has multiple outputs. This doesn't apply to most nodes but if you make something like a data node where every output returns a single line then you might need to use this. The function returns a dictionary. This will be explained below. layout_type: This is needed if you create a layout node. An example is the Row node which returns \"row\". This can be used by connected nodes to find the layout type it should use. A Label node might call it on the connected node to return row.label data_type This is only needed if you create a node that uses data properties. An example is the scene data properties node which returns \"bpy.types.\" combined with the type of the selected property, which can be found using .fixed_type. It should also return \"bpy.types.\" + the data type + \".bl_rna.properties['\" + the selected property + \"']\" if the selected property is a collection. This can be used by connected nodes to get the properties of the connected data type using .bl_rna.properties and .fixed_type. needed_imports: This contains a list of strings of the things that this node needs to import. The most common example is [\"bpy\"] get_register_block: This is only needed if _should_be_registered is true. It returns a list of strings, where every string is one line in the register function of the addon. get_unregister_block: This is only needed if _should_be_registered is true. It returns a list of strings, where every string is one line in the unregister function of the addon. Evaluate function: The evaluate function returns a dictionary containing a list called \"blocks\" and a list called \"errors\". Blocks: This is the code that the node creates. The blocks list contains dictionaries. These dictionaries have the following parameters: lines: This is a list of code lines. Each line is either a list or a node socket. If it is a node socket, the compiler will call evaluate on the sockets node to generate the corresponding lines of code. This means that a socket without a list equates to multiple new lines of code. The other option is to have a list of strings and sockets. The sockets in these lists should belong to nodes which only return single lines. An example for this would be a print node where you have something like [\"print(\", connected_socket, \")\"]. indented: This is also a list of lists and sockets and works the same way as the lines list. The different is that these lines will come after the lines list and will be indented. This can be used if you need to indent code in your node. You can nest these code blocks, meaning that you can put dictionaries with lines and indented code inside other lists of lines or indents. With this you should be able to create any code you could need. Errors: This is a list of dictionaries that have the following parameters. It contains the errors that the node has. This could be that the user has connected a wrong input or something similar: error: This is the type of error. It's a string from the following list: [\"test_error\", \"wrong_socket_inp\", \"no_connection_inp\", \"wrong_socket_out\", \"no_connection_out\", \"no_connection\", \"no_layout_connection\", \"no_name_func\", \"no_name_var\", \"no_var_available\", \"no_prop_selected\", \"wrong_prop\"] node: This is the node that caused the error. Usually this is self Helpful tools: We provide a few tools that should help you with the evaluating of nodes. You don't have to use these but they should make your life easier. SocketHandler: You can access the socket handler with self.SocketHandler. It helps you with getting the value of inputs that could be connected to other nodes. The most important function here is socket_value which takes the input socket. It also can take an optional parameter for if the result should be returned as a list which is only useful for layout and program sockets. The function returns the value of the socket or the connected socket. It also checks for errors and returns those as well. The second useful function is get_layout_values which returns all layout values as well as the errors for the given node ErrorHandler: The function you will use here is handle_text. It checks for keywords in the text to see if they don't work with python syntax. This could be useful when creating something like a function which can't have any type of name","title":"Setting up a node"},{"location":"developers/setup/","text":"Setup This will tell you how we recommend developing a package. If you find another way to do it, feel free to do so. Project setup Start by finding the folder where you have installed the visual scripting addon. You can find this in the user preferences in the addons panel under File . In this folder you'll find a folder called nodes. This is the folder you'll work in. When you open up the folder you will find the directories corresponding to the node categories, mentioned in the introduction. These are the installed categories and nodes. When a user installs your package, the zip files content will go in here. Start by opening the nodes folder in your IDE of choice. We use Visual Studio Code, but you can use whatever you'd like for this. In the nodes folder you'll find a folder called base . This folder holds some of the basic functionality regarding the nodes and node trees. You won't need to pay any attention to this folder. You can't add nodes in here either as it's not a category. All other folders are existing categories with existing nodes. Here you can add your own nodes. You should now be able to add nodes as explained below. To reload any changes you make, restart blender.","title":"Project Setup"},{"location":"developers/setup/#setup","text":"This will tell you how we recommend developing a package. If you find another way to do it, feel free to do so.","title":"Setup"},{"location":"developers/setup/#project-setup","text":"Start by finding the folder where you have installed the visual scripting addon. You can find this in the user preferences in the addons panel under File . In this folder you'll find a folder called nodes. This is the folder you'll work in. When you open up the folder you will find the directories corresponding to the node categories, mentioned in the introduction. These are the installed categories and nodes. When a user installs your package, the zip files content will go in here. Start by opening the nodes folder in your IDE of choice. We use Visual Studio Code, but you can use whatever you'd like for this. In the nodes folder you'll find a folder called base . This folder holds some of the basic functionality regarding the nodes and node trees. You won't need to pay any attention to this folder. You can't add nodes in here either as it's not a category. All other folders are existing categories with existing nodes. Here you can add your own nodes. You should now be able to add nodes as explained below. To reload any changes you make, restart blender.","title":"Project setup"}]}